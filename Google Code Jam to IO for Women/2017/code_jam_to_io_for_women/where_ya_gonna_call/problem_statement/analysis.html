
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Code Jam to I/O for Women 2017 - Code Jam to I/O for Women</h3><h1>Analysis: Where Ya Gonna Call?</h1><h2>Where Ya Gonna Call?: Analysis</h2>
<p>
We can model the input as a
<a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)">
weighted undirected graph</a>. The question to be answered is similar
to finding the graph's
<a href="https://en.wikipedia.org/wiki/Distance_(graph_theory)#Related_concepts">radius</a>.
In fact, we are asked to minimize the input graph's radius by possibly
adding a single node inside an existing edge. This view is not only a succinct and
accurate way to describe the problem, but also a first step towards a solution.
</p>
<h3>Small dataset</h3>
<p>
One solution for the Small relies on a simple fact: the
result is always an integer multiple of 1/2, and if the optimal location is inside an edge,
it is always at a point that is at a distance from one of
the incident nodes that is an integer multiple of 1/2. This property
is not hard to prove: if the location is in a building, all distances
to it are integers. If not, let L be a location and B be a farthest
building at distance D. Let B' be the farthest building among those
whose minimum path approaches L from the other side of the edge as B's
minimum path, with distance D'. If there were no buildings whose minimal path approaches L
from the other side, L would not be an optimal location, since we could move L towards B
decreasing all distances.
If D' &lt; D, we could move the location slightly towards B
and decrease the overall minimum, so D' &le; D, which together with D' &ge; D
by definition implies D' = D. Notice that
the fractional parts of both D and D' only depend on where L is located
on the edge, because the rest of each distance comes from a distance between buildings,
which is an integer. Therefore, since the fractional parts
of D and D' are equal, the fractional parts of the edge on both sides
of L are equal, and thus an integer multiple of 1/2.
</p><p>
With this property in mind, and the limitation that the maximum edge length is 2 in the Small
dataset, there are only 3 positions on each edge
that can contain an optimal location (at distances 0.5, 1, and 1.5 from one end).
For each of these, we can find the farthest building. To do that, we can
use <a href="https://en.wikipedia.org/wiki/Dijkstra's_algorithm">Dijkstra's algorithm</a>.
We also have to
consider the radius of the original graph (which represents choosing a
location in a building), which we can do by running the same algorithm
starting at each building. Then, we just take the minimum farthest
distance from all of those options. The running time of this solution
is O(M<b>B</b><sup>4</sup>) where M is the maximum length of an edge. This is
because we need to run Dijkstra’s algorithm 2M-1 times per edge for up to
O(<b>B</b><sup>2</sup>) edges and once per node for O(<b>B</b>) nodes
(a total of O(M<b>B</b><sup>2</sup>) times), and each run
takes O(<b>B</b><sup>2</sup>) time.
</p>
<h3>Large dataset</h3>
<p>
The approach outlined for the Small dataset does not work for the Large,
because the edges can be really long and thus the number of locations
to try is too large, even when restricted to integer multiples of 1/2.
</p><p>
What we can do to simplify the problem is to use
<a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">binary search</a>. That is,
write an algorithm to determine whether there is a location with farthest
distance D or less. The statement is clearly false for some interval
[0, X) of values for D and true for [X, infinity), so we can
simply binary search for X.
</p><p>
The simplification that we obtain is that we can now check for a fixed
distance. We start by finding the distance between all pairs of
buildings. We can either run Dijkstra's algorithm once per building as mentioned above, or use
something simpler for all pairs like
<a href="https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm">Floyd-Warshall's</a>.
We can then iterate over each edge to see whether there is a viable location within it.
For a fixed edge, we iterate over each building and see where in the edge a
location could be at a distance D or less from that building. To go to a point
inside edge (I,J) from building K, there are two options: go from K to
I and then move inside the edge, or go from K to J and then move inside
the edge. Since we now know the distance from K to I and J, we can calculate
the interval of positions within the edge that can be reached with
distance D from each end I and J. Then, if those intervals cover the
entire edge (by overlapping or because one of them is big enough), then
any location inside (I,J) is reachable from K with a distance D or less.
Otherwise, there is some interval
of unreachable locations. We record such intervals for each building
and then check whether the union of all those intervals
covers all of (I,J). If it does, no location inside (I,J) is viable.
Otherwise, there is at least one that is.
</p><p>
To check if a given set of intervals fully covers another interval A there is a
greedy algorithm: sort the intervals by starting point and process them
while keeping a current covered upper bound U, which is initialized to the lower bound of A.
While U is less than the upper bound of A, for each interval,
if its lower bound L is greater than U, then there
is an uncovered interval (U, L) and we are done. Otherwise, if the upper bound H of the current
interval is greater than U, set U := H. If
the iteration finishes due to U becoming larger than A's upper bound,
all of A is covered. Otherwise we either found a hole or there is one between the
last value of U and the upper bound of A.
</p><p>
For this solution we run Floyd-Warshall's which takes O(<b>B</b><sup>3</sup>) time and then
run a procedure for each of O(<b>B</b><sup>2</sup>) edges. This procedure iterates all <b>B</b>
nodes within a binary search, which takes O(log <b>B</b>M) to converge (remember M is the maximum
length of an edge, so <b>B</b>M is an upper bound on the output), which makes it take time
O(<b>B</b><sup>3</sup> log <b>B</b>M) overall.
</p><p>
Notice that since we are
binary searching for X, precision is not an issue, as a bad decision due to precision
would only give a slightly larger or slightly smaller result. Additionally,
we could use the property of the result being a multiple of 1/2 to
do all calculations on integers by doubling all edges in the input and
dividing by 2 at the very end.
</p><p>
A number of people tried to use <a href="https://en.wikipedia.org/wiki/Ternary_search">ternary
search</a> to solve this problem. Ternary search assumes a convex or concave function, and the
function in this case (the farthest distance for each point within an edge) is neither. The
distance from each point to a single fixed building is indeed a concave function. However, the
maximum of many concave functions is not a concave nor a convex function. Some ternary search
implementations may suceed in the Small because of the really small number of critical points,
which may all be tried even under the flawed assumption.
</p>

    </div>
  </body>
</html>
