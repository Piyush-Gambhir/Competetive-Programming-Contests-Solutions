
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Code Jam to I/O for Women 2020 - Code Jam to I/O for Women</h3><h1>Analysis: Imbalance Obviation</h1><h3>Test Set 1</h3>
<p>
  For Test Set 1, we can enumerate all 2<sup>N</sup> possible strings of
  length <b>N</b> composed only of <code>L</code>s and/or <code>R</code>s, and
  check whether each one would break the scale, by simulating the process
  explained in the problem statement. We can then output any one string that
  works; the statement guarantees that at least one exists.
</p><p>
  This process has a time complexity of O(<b>N</b>&times;2<sup><b>N</b></sup>)
  for each test case, which is fast enough for this test set.
</p>
<h3>Test Set 2</h3>
<p>
  Suppose we've placed our first marble on one of the pans. Then the second
  marble must go on the other pan. Now we are effectively back in the same
  situation &mdash; the scale is balanced and we have our choice of pan again,
  but then that choice forces the next choice, and so on.
</p><p>
  Similarly, if the number of marbles is even (as is always the case in this
  test set), the scale is balanced before we start to remove marbles. This
  means we can remove the first marble from either pan, but the second marble
  we remove must come from the other one. The third marble can be removed from
  either one again, but the fourth must be removed from the other one, and so
  on.
</p><p>
  We can formalize the first observation by saying that marbles 2i and 2i-1
  must go on different pans, for every i &ge; 1. We can formalize the second
  observation by saying that marbles <b>A</b><sub>2i-1</sub> and
  <b>A</b><sub>2i</sub> must go on different pans, for every i &ge; 1.
</p><p>
  The rules above help to reduce this problem to
  <a href="https://en.wikipedia.org/wiki/Graph_coloring#Vertex_coloring" target="_blank">graph coloring</a>
  . In our graph, each node represents a marble, and each pair of marbles that
  are required to be on different pans is connected by an edge. The resulting
  graph has <b>N</b> nodes and at most <b>N</b> edges, and each of the nodes is
  connected to at most 2 other nodes. If we can 2-color the graph, we can use
  one of the colors (it doesn't matter which one) to represent the left pan and
  the other to represent the right pan, and then we will have our desired
  assignment of marbles to pans. Better yet, 2-coloring takes at most linear
  time!
</p><p>
  How can be sure that a 2-coloring is possible, apart from the assurances in
  the problem statement that a solution always exists? Well, this is possible
  if and only if there are no cycles of odd length &mdash; can we show that?
</p><p>
  The constraints from the marble-adding phase pair up nodes 1 and 2, 3 and 4,
  etc. Call these the "original pairs". Any additional constraint from the
  marble-removing phase (that is, from the input permutation <b>A</b>) can do
  one of the following: match an original pair's edge, in which case that pair
  cannot have other connections to the rest of the graph and is not a cycle, or
  add an edge that connects two of the original pairs. Then, any path that does
  not repeat edges alternates between edges connecting original pairs and edges
  from the marble-removing phase that do not connect original pairs. Therefore,
  any cycle formed is of even length, or else it would have two edges of the
  same type one after the other.
</p><p>
  So, the resulting graph is
  <a href="https://en.wikipedia.org/wiki/Bipartite_graph" target="_blank">bipartite</a>
  and our strategy will always find a solution.
</p>
<h3>Test Set 3</h3>
<p>
  Let's reconsider the above strategy and see if we can make it work for odd
  <b>N</b>:
  <ul>
    <li>The first rule ("marbles 2i and 2i-1 must go on different pans, for
      every i &ge; 1") is still fine &mdash; the pans will be balanced right
      before we place marble <b>N</b>, so it does not matter where we put that
      marble.</li>
    <li>After we remove the marble <b>A<sub>1</sub></b> (more on that in a
      moment), the pans will be balanced again, so we need our second and third
      marbles to be removed from opposite sides, and then our fourth and fifth,
      and so on. We can replace the second rule above ("marbles
      <b>A</b><sub>2i-1</sub> and <b>A</b><sub>2i</sub> must go on different
      pans, for every i &ge; 1") with: marbles <b>A</b><sub>2i</sub> and
      <b>A</b><sub>2i+1</sub> must go on different pans, for every i
      &ge; 1. (If we write this as "marbles <b>A</b><sub><b>N</b>-2i+2</sub> and
      <b>A</b><sub><b>N</b>-2i+1</sub> must go on different pans, for every i
      &ge; 1", then the condition is the same as in the even-<b>N</b> case.)
    </li>
    <li>Finally, the first marble removed, <b>A<sub>1</sub></b>, must come from
      the heaviest pan. We know that marble <b>N</b> is in the heaviest pan, so
      one way to represent this constraint is to replace both
      <b>A<sub>1</sub></b> and <b>N</b> in the graph with a new "node" that
      represents them both. We can do this because we know that marble <b>N</b>
      has no constraints arising from the marble-adding phase, and marble
      <b>A<sub>1</sub></b> has no constraints arising from the marble-removing
      phase. So the argument from earlier about no odd cycles still holds;
      this new "node" can only be entered via one type of constraint and exited
      via another.
  </ul>
</p><p>
  A less complex version of the above idea is: we can introduce an imaginary
  extra marble that we add last and remove first, making the total number of
  marbles even again. We can add <b>N</b> + 1 to the end of the identity
  permutation, and to the beginning of the input permutation (since it was the
  last marble added, it's always safe to remove it first, restoring a previous
  valid state). Then we can solve the problem as in the even version above, and
  finally chop off the last character of the sequence. This gives us the same
  O(<b>N</b>) time complexity as in Test Set 2.
</p>
<h3>A note on 2-SAT</h3>
<p>
  A more abstract view of the same solution is to represent each marble as a
  Boolean variable (where true corresponds to assignment to one pan and false
  to assignment to the other pan), and then encode the requirements explained
  above as two implications of literals, which are in turn disjunctions of
  literals. The conjunction of all those requirements is a valid input to
  <a href="https://en.wikipedia.org/wiki/2-satisfiability" target="_blank">2-satisfiability</a>
  (2-SAT). Notice that the graph created in the typical 2-SAT algorithm is
  exactly 2 copies of the graph mentioned for the solution above, so the
  algorithm ends up being the same in both cases.
</p>

    </div>
  </body>
</html>
