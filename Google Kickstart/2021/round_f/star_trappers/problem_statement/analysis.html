
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Kick Start 2021 - Round F</h3><h1>Analysis: Star Trappers</h1><h3>Test Set 1</h3>
<p>
Say, we have just one polygon and the point we need to capture (called $$$P$$$
henceforth). We need a way to check if that point is inside the polygon or not.
This problem is known as <a
    href="https://en.wikipedia.org/wiki/Point_in_polygon" target="_blank">Point
    in Polygon</a> and ray casting is one of the standard ways to solve it.
Now, for the first test set, we can generate all possible simple polygons and
check the minimum perimeter polygon which contains the point. Following steps
show how to generate all simple polygons:
<ol>
    <li>Generate all distinct permutations from the given set of points (minimum
        $$$3$$$ points). Treat each permutation as a polygon with points
        describing consecutive vertices of that polygon.</li>
    <li>For each polygon, if any two edges intersect each other, discard that
        polygon.</li>
    <li>All remaining permutations will describe all possible simple
        polygons.</li>
</ol>
</p>

<p>
<i>Runtime Analysis:</i> To generate $$$R$$$ distinct permutations from
$$$\mathbf{N}$$$ points will take $$$\mathbf{N}$$$ <a href="https://en.wikipedia.org/wiki/Permutation"
    target="_blank">permutations</a> $$$R$$$ (called $$$\mathrm{P}^{\mathbf{N}}_R$$$)
and then checking for intersection of any two edges will take $$$(R - 1) \times
(R - 2)$$$. Then for each polygon it will take $$$(R - 1)$$$ checks for ray
casting. So, total runtime will be: <br />
$$$O(\sum_{R=3}^{\mathbf{N}}\mathrm{P}^{\mathbf{N}}_R \times (R - 1) \times (R - 2) \times (R
- 1) = O(\sum_{R=3}^{\mathbf{N}}\mathrm{P}^{\mathbf{N}}_R \times R^3) = O(\mathbf{N}! \times
\mathbf{N}^3)$$$.<br />
Note: This might look like it will TLE but most of the checks would not be
performed. We can improve this runtime, though, using <a
    href="https://en.wikipedia.org/wiki/Convex_hull" target="_blank">convex
    hull</a>. A convex hull of a simple polygon will always include the initial
area of a simple polygon and will have smaller or equal perimeter. The runtime
in that case will be:<br />
$$$O(\sum_{R=3}^{\mathbf{N}}\mathrm{C}^{\mathbf{N}}_R \times (R \times log(R)) \times (R - 1))
= O(2^\mathbf{N} \times \mathbf{N}^2 \times log(\mathbf{N}))$$$
</p>

<h3>Test Set 2</h3>
<p>
Notice that if a point is inside a polygon with more than $$$4$$$ points, we can
reduce it to a triangle ($$$ABC$$$ in the image below) or a quadrilateral
($$$ABCD$$$ in the image below) which contains the point.
</p>

<p align="center">
<img src="images/point_in_triangle.jpg" alt="P inside triangle"/>
<img src="images/point_in_quadrilateral.jpg" alt="P on quadrilateral diagonal"/>
</p>

<p>
Note: It can be some other triangle/quadrilateral in the above polygon, the
image is just for illustration.
</p>

<p>
So, we can generate all possible quadrilaterals and triangles and then check the
minimum perimeter polygon which contains the point.
</p>

<p>
<i>Runtime Analysis:</i> We can generate all sets of points with set size being
$$$4$$$ (for quadrilateral) and $$$3$$$ (for triangle) from the given set of
points taking $$$O(\mathbf{N}^4 + \mathbf{N}^3) = O(\mathbf{N}^4)$$$. Checking "Point in Polygon" in
this case will be constant time.
</p>

<h3>Test Set 3</h3>
<p>
The observation required for this set is that if the point $$$P$$$ is on one of
the diagonals in the quadrilateral, it must be at the intersection of the
diagonals. If it is not, then we can reduce the quadrilateral to a triangle
with a lesser perimeter (as in the following diagram, quadrilateral $$$ABCD$$$
can be reduced to triangle $$$ABC$$$).
</p>

<p align="center">
<img src="images/point_on_one_diagonal.jpg" alt="P only on one quadrilateral diagonal"/>
</p>

<p>
Another observation is that among the points collinear to $$$P$$$ only one point
closest to $$$P$$$ on both side matters. Other points will always create
quadrilateral with larger perimeter. So, all collinear segments of interest are
unique. <br />
So, for this set we can check all the triangles first. Then to generate
quadrilaterals, we can find the diagonals as:
<ol>
    <li>Find polar angles of all points, treating $$$P$$$ as origin.</li>
    <li>Group all points with same polar angles in one equivalence class.</li>
    <li>Choose the point closest to $$$P$$$ in each equivalence class and
        discard rest of the points.</li>
    <li>Now, generate line segments from the remaining points. For each polar
        angle between $$$[0, \pi)$$$ radians (called $$$\theta$$$), check if we
        have a point at $$$\theta + \pi$$$. These two points make one line
        segment (note that $$$P$$$ lies on this segment).</li>
    <li>These line segments are treated as diagonals of the quadrilateral.</li>
</ol>
</p>

<p>
<i>Runtime Analysis:</i> The triangle case remains the same, taking
$$$O(\mathbf{N}^3)$$$. For quadrilateral, we will generate at most $$$\mathbf{N} / 2$$$ sets
of points in $$$O(\mathbf{N})$$$ and then we can check all combinations of these
segments for possible quadrilateral candidates in $$$O((\mathbf{N}/2)^2)$$$. So, total
runtime will be:<br />
$$$O(\mathbf{N}^3 + \mathbf{N} + (\mathbf{N}/2)^2) = O(\mathbf{N}^3)$$$
</p>


  <div class="test-data-download-wrapper">
    <div class="test-data-download-header">
      <div class="test-data-download-header-text">Test Data</div>
      <div class="test-data-download-header-download-button">
        <a href="test_data.zip" target="_blank">
          <i class="material-icons grey">save_alt</i>
        </a>
      </div>
    </div>
    <div class="test-data-download-content">
      <div class="test-data-download-warning">
        <span class="material-icons" style="color: grey; vertical-align: middle;">info</span>
        <span style="vertical-align: middle;">We recommend that you practice debugging solutions without looking at the test data.</span>
      </div>
    </div>
  </div>


    </div>
  </body>
</html>
