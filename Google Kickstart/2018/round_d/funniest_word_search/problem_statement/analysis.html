
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Kick Start 2018 - Round D</h3><h1>Analysis: Funniest Word Search</h1><h2>Funniest Word Search: Analysis</h2>
<h3>Small dataset</h3>
<p>
As we approach the problem, we want to decide on what we can feasibly calculate. Since the upper
bounds for <b>R</b> and <b>C</b> are reasonably low, we know that we can iterate through all
combinations of (i1, j1, i2, j2) where (i1, j1) is the top left cell of a subgrid and (i2, j2) is
the bottom right cell; however, recalculating the total length of words found for every subgrid will
still take too long. Note that since the length of each valid word is 1 in the Small dataset, the
total length from finding a single instance of a word is 4. One solution is to calculate prefix sums
S(i, j) and then calculate totals[i1, j1, i2, j2] = S(i2, j2) - S(i1 - 1, j2) - S(i2, j1 - 1) + S(i1
- 1, j1 - 1).
</p>
<p>
The prefix sum solution is simpler, but we will examine a different algorithm that extends more
readily to the Large dataset. For every i1, create an array column_sum[j] which, when we iterate
through values for i2, will represent the total length of words found in the column bounded by (i1,
j, i2, j). For every i2 &ge; i1, scan through row i2 to update column_sum[j] by adding 8 if (i2, j)
is a word. After doing so, for every j1, start with totals[i1, j1, i2, j1] = column_sum[j1], and for
every j2 &gt; j1, update totals[i1, j1, i2, j2] = totals[i1, j1, i2, j2 - 1] + column_sum[j2]. As we
calculate totals[], keep track of the best <i>fun size</i> and how many times it occurs. As a
side-note, it is not necessary to store the entire totals[] array, since we only use one previous
calculation. This algorithm takes O(<b>R</b><sup>2</sup><b>C</b><sup>2</sup>) time.
</p>
<h3>Large dataset</h3>
<p>
Knowing that all words are of length 1 is very beneficial in the Small dataset for quickly updating
our column sums. Luckily, with a bit of precomputation, updating can be just as easy for the Large
dataset. As long as our precomputations are not slower than
O(<b>R</b><sup>2</sup><b>C</b><sup>2</sup>) time, we should not have any problems.
</p>
<p>
Before running our algorithm, we can add the reverse of every word to our dictionary, so we only
need to scan for words going from left to right (now referred to as going right) and top to bottom
(going down).
</p>
<p>
We can observe that the length of a word limits where it can begin. Using this property, we can
reduce the number of words to search for at each location. As a result, we want to create a lookup
table word_lookup[i] which has a list of words of length i at each respective index. Now let us use
two more lookup tables right[i, j, k] and down[i, j, k] which will keep track of how many words
start at cell (i, j) and have length &le; k going right and down, respectively. We can populate the
tables in the following manner: for every (i, j) start with length k = 1. While k is a valid length
for a word going right starting at (i, j) with respect to the entire grid, check every word in
word_lookup[k] to see if it can be found going right starting at (i, j). Record right[i, j, k] = (k
* number of words found) + right[i, j, k - 1]. Increment k until it is not a valid length for a word
starting at (i, j). Repeat for words going down instead of going right.
</p>
<p>
Now, we can use an algorithm which is very similar to the one we used on the Small dataset. Let us
just focus on words going right. We will still use totals[i1, j1, i2, j2] for the same purpose. For
every i1, have a table right_column_sums[j, k] which, when we iterate through values for i2, will
represent the total length of words going right with length &le; k which start at the column bounded
by (i1, j, i2, j). For every i2 &ge; i1, scan through row i2 and update right_column_sums[j, k] =
right_columns_sums[j, k] + right[i2, j, k] for all valid values of k (remember that a word must be
short enough to start at column j). Then, we will work left to right. For every j2, with j2 starting
at <b>C</b> - 1 and totals[i1, j2, i2, j2] = right_column_sums[j2, 1], and for every j1 &lt; j2,
update totals[i1, j1, i2, j2] = totals[i1, j1 + 1, i2, j2] + right_column_sums[j1, j2 - j1 + 1]. The
process for words going down is analogous, but with the rows and columns switched, and starting our
iteration on columns instead of rows. As totals[] is finalized for words going both right and down,
keep track of the best <i>fun size</i> and how many times it occurs. It is also possible to not
store the entirety of totals[] in the Large dataset solution and have a space complexity of
O((<b>R</b> + <b>C</b>)<sup>3</sup>) by solving for words going both right and down in the same
loop, but doing so requires a slightly different precomputation step.
</p>
<p>
We still need to analyze the time complexity of the Large dataset solution. Creating word_lookup[]
takes O(<b>W</b>) time. Creating right[] or down[] takes O(<b>R</b> × <b>C</b> × <b>W</b>) time.
Creating all right_column_sums[] takes O(<b>R</b><sup>2</sup><b>C</b>) time. Populating totals[]
still has a longer runtime than any of our previously mentioned steps, resulting in our solution
taking O(<b>R</b><sup>2</sup><b>C</b><sup>2</sup>) time.
</p>


  <div class="test-data-download-wrapper">
    <div class="test-data-download-header">
      <div class="test-data-download-header-text">Test Data</div>
      <div class="test-data-download-header-download-button">
        <a href="test_data.zip" target="_blank">
          <i class="material-icons grey">save_alt</i>
        </a>
      </div>
    </div>
    <div class="test-data-download-content">
      <div class="test-data-download-warning">
        <span class="material-icons" style="color: grey; vertical-align: middle;">info</span>
        <span style="vertical-align: middle;">We recommend that you practice debugging solutions without looking at the test data.</span>
      </div>
    </div>
  </div>


    </div>
  </body>
</html>
