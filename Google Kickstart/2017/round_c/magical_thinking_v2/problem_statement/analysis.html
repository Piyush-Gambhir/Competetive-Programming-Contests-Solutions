
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Kick Start 2017 - Round C</h3><h1>Analysis: Magical Thinking v2</h1><h2>Magical Thinking: Analysis</h2>

<h3>Small dataset</h3>
<p>
  In the Small dataset, there is only one other friend to consider, and we
  know how many questions <b>S<sub>0</sub></b> they got right. We need to
  choose exactly <b>S<sub>0</sub></b> of the questions to be the ones they got
  right (call this set R); that means they got the other <b>Q</b> -
  <b>S<sub>0</sub></b> questions wrong (call this set W). Moreover, we need to
  do this in the way that maximizes our own score.
</p><p>
  Let's divide the questions into two types: type A when we gave the same
  answer as our friend, or type D when we gave different answers. Suppose
  that we assign the questions to sets R and W in some way, and suppose that
  there is a type D question in set R, and a type A question in set W. Then we
  got both of those questions wrong! But if we swap the two, then we instead
  got both questions right. So it is always advantageous to make such swaps,
  and we should always load up set R with as many type A questions as we
  possibly can. If there are not enough type A questions to do this, then we
  must fill up the rest of set R with type D questions.
</p><p>
  We can either implement this greedy strategy, or generalize it into a
  formula: if X is the number of questions on which we agree with our friend,
  then the answer turns out to be <b>Q</b> - |<b>S<sub>0</sub></b> - X|.
</p><p>
  Another possible approach for the Small dataset is to use brute force. Even
  in the worst case of <b>Q</b> = 10, there are only 2<sup>10</sup> = 1024
  different possible sets of answers. We can check all of them and see
  which ones are consistent with our friend's score, and which of those gives
  us the highest score.
</p>
<h3>Large dataset</h3>
<p>
  The Large dataset introduces two additional complications. For one thing,
  there can now be up to 50 questions, so the brute force approach mentioned
  above won't work; 2<sup>50</sup> is over 10<sup>15</sup>, and there are far
  too many possible sets of answers to check.
</p><p>
  Our greedy method above will work for <b>N</b> = 1, <b>Q</b> = 50, but adding
  a second friend introduces some complications. For example, trying to make
  greedy decisions about one friend in the same way we did for Small
  dataset 1 might cause the other friend to end up with the wrong score.
  However, we don't need a greedy approach, because we can take advantage of
  the small number of types of questions. When <b>N</b> = 2, there are only
  four types:
</p>
<ol>
  <li>Both friends agree with us.</li>
  <li>Only friend 1 agrees with us.</li>
  <li>Only friend 2 agrees with us.</li>
  <li>Neither friend agrees with us.</li>
</ol>
<p>
  We can try every possible tuple (a, b, c, d) of the numbers of Type 1, 2, 3,
  and 4 questions that we got right, with 0 &le; a &le; the number of Type 1
  questions, 0 &le; b &le; the number of Type 2 questions, and so on. Any
  tuples that do not cause both friends to have the correct scores should be
  discarded. We can then choose the remaining tuple for which a + b + c + d is
  maximized. This method is O(<b>Q</b><sup>4</sup>), but the greatest possible
  number of such tuples to check occurs when <b>Q</b> = 50 and there are 12 or
  13 of each of the four types, and even then, there only about 25000
  possibilities to check.
</p><p>
  Another option for this dataset is to use
  <a href="https://en.wikipedia.org/wiki/Dynamic_programming">dynamic programming</a>.
  For example, we can start with a set containing only the list [0, 0, 0],
  which represents that at the start of the test, before any questions are
  answered, we have 0 points, friend 1 has 0 points, and friend 2 has 0 points.
  Then, suppose that our answer to the first question is F, our first friend
  answered T, and our second friend answered F. There are two options: either
  the real answer to the first question is F (for which case we create the list
  [1, 0, 1], since we and the second friend have earned a point, but the first
  friend has not), or the real answer is T (for which case we create the list
  [0, 1, 0]). Then we replace our old set with the new set ([1, 0, 1],
  [0, 1, 0]), and for each list in that set, we in turn consider what happens
  when we answer F or T for the second question, and so on. Once we have
  finished, we check for the list in which our friends' scores are both correct
  and we have the highest possible score.
</p><p>
  Why is this method any better than brute force? The key difference is that if
  we create a list that is already in our set, we do not add another copy of
  it, so we do not waste time individually considering many nearly equivalent
  (for our purposes) answer sets. Because our scores and our friends' scores
  can range from 0 to <b>Q</b>, inclusive, there are
  (<b>Q</b> + 1)<sup>N + 1</sup> possible lists; since (as an upper bound) we
  have to check all of them once for each question, the method is
  O(<b>Q</b><sup>N + 2</sup>). This is O(<b>Q</b><sup>4</sup>) when
  <b>N</b> = 2. In practice, this is a "slower O(<b>Q</b><sup>4</sup>)" than
  the method above, since we may need to check 51<sup>3</sup> &times; 50 =
  over 6 &times; 10<sup>6</sup> possibilities, but it is still easily fast
  enough to solve the Large dataset. The approach also works just fine with a
  three-dimensional array instead of a set, but the set lets us avoid checking
  for the existence of all possible lists at each step of the process.
</p>


  <div class="test-data-download-wrapper">
    <div class="test-data-download-header">
      <div class="test-data-download-header-text">Test Data</div>
      <div class="test-data-download-header-download-button">
        <a href="test_data.zip" target="_blank">
          <i class="material-icons grey">save_alt</i>
        </a>
      </div>
    </div>
    <div class="test-data-download-content">
      <div class="test-data-download-warning">
        <span class="material-icons" style="color: grey; vertical-align: middle;">info</span>
        <span style="vertical-align: middle;">We recommend that you practice debugging solutions without looking at the test data.</span>
      </div>
    </div>
  </div>


    </div>
  </body>
</html>
