
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Kick Start 2017 - Round F</h3><h1>Analysis: Kicksort</h1><h2>Kicksort: Analysis</h2>
<p>
  In Quicksort, the best pivots at any stage are the ones that are closest to
  the <i>median</i> of the current list (although we would have no way of
  knowing which ones those are without doing some additional work before
  choosing!) This problem hinges on a misinterpretation of that idea, in which
  we take pivots from near the middle <i>index</i> of the list instead. Unless
  our sequence happens to be already sorted or close to sorted, this is no
  better than choosing an arbitrary index!
</p>
<h3>A Small-only approach</h3>
<p>
  The sequences in the Small dataset can have between 2 and 4 elements. There
  are only 2! + 3! + 4! = 32 different permutations that meet these criteria.
  This enables some strategies that do not usually work in Kickstart. For
  example, we can pre-solve each case by hand, or use nested conditional
  statements that take advantage of the small size of the sequence. But we
  recommend using one of the two approaches below instead.
</p>
<h3>A quadratic simulation approach</h3>
<p>
  The most straightforward general approach is to actually run the Kicksort
  algorithm on the given sequence, and see whether it ever picks a pivot that
  is <i>not</i> worst-case. One possible complication is figuring out how to
  have this recursive algorithm pass information up the call chain if it does
  find a non-worst-case pivot; one option is to have it throw an exception that
  can then be caught. We must also be careful not to overflow the stack with
  recursive calls, since there can be <b>N</b> of them; one way to avoid this
  is to use our language's provided way to change the system's stack size.
  (Warning: This sort of system tweaking can be dangerous in real-world
  applications, which tend to avoid deep recursive strategies like this one.)
</p><p>
  Quicksort is famously O(<b>N</b><sup>2</sup>) when it consistently picks
  worst-case pivots, and that is what many of our simulations will do, so this
  strategy takes O(<b>N</b><sup>2</sup>) time. This is still fast enough to
  solve the Large dataset, but can we do better?
</p>
<h3>A linear approach</h3>
<p>
  First of all, let us consider different sequences of the same length that
  have "YES" answers &mdash; that is, the ones for which Kicksort will always
  pick worst-case pivots. Even though the pivots themselves may have different
  values, Kicksort will always use the same <i>indexes</i>, in the same order,
  as pivots. For a sequence of length 6, for example, it will pick index 2 as a
  pivot, and then divide the other values into one empty list (which is
  unimportant since no pivot is chosen from it) and one list of length 5
  containing the remaining values. (It turns out not to matter for our purposes
  whether that list is the "low" or "high" one.) Then it will pick index 2 from
  that list of length 5, which corresponds to index 3 in the original list. If
  we continue to trace such a case, we find that the indexes chosen from the
  original list will be 2, 3, 1, 4, 0, 5. That is, we are starting at index
  floor(<b>N</b> - 1) / 2, then jumping 1 to the right, then 2 to the left,
  then 3 to the right, and so on. This does not depend at all on the values in
  the list!
</p><p>
  A similar pattern holds for lists of odd length, although in that case, the
  first jump is 1 to the left. Knowing this, we can visit the indexes of our
  pivots in order, without doing any simulation. It is not too hard to
  implement the pattern of changing direction and adding a distance of 1 with
  each new jump.
</p><p>
  Each time we visit a new index, we check whether it holds either the lowest
  or highest value that has not already been used. If this continues all the
  way through the last index, we have a "YES" case. However, if we ever
  encounter a value that does not satisfy those conditions, then we have a "NO"
  case and we can stop.
</p><p>
  At this point, we can take advantage of the fact that our sequences are
  permutations of numbers from 1 to <b>N</b>. (Of course, in real life, we
  could "sort" such sequences in constant time, without ever reading them, if
  we knew the length in advance!) We know at the outset that our lowest unused
  value is 1 and our highest unused value is <b>N</b>. When our current value
  matches this lower bound, we increment it by 1, because we already know that
  the next lowest value is exactly 1 more than the previous lowest; similarly,
  when our pivot matches the upper bound, we increment our upper bound by 1. We
  only need to keep track of these two values as we go.
</p><p>
  Since we potentially have to bounce around the entire sequence, this strategy
  takes O(<b>N</b>) time. It is unusual for a problem about sorting to have
  a solution that takes less than O(<b>N</b> log <b>N</b>) time, but in this
  case, it is a consequence of having restricted our sequences to permutations.
</p>


  <div class="test-data-download-wrapper">
    <div class="test-data-download-header">
      <div class="test-data-download-header-text">Test Data</div>
      <div class="test-data-download-header-download-button">
        <a href="test_data.zip" target="_blank">
          <i class="material-icons grey">save_alt</i>
        </a>
      </div>
    </div>
    <div class="test-data-download-content">
      <div class="test-data-download-warning">
        <span class="material-icons" style="color: grey; vertical-align: middle;">info</span>
        <span style="vertical-align: middle;">We recommend that you practice debugging solutions without looking at the test data.</span>
      </div>
    </div>
  </div>


    </div>
  </body>
</html>
