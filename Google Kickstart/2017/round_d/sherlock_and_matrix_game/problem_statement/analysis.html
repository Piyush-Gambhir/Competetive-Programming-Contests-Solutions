
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Kick Start 2017 - Round D</h3><h1>Analysis: Sherlock and Matrix Game</h1><h2>Sherlock and The Matrix Game : Analysis</h2>

<h3>Brute force approaches</h3>
<p>
  In the Small dataset, <b>N</b> (which is the size of arrays <b>A</b> and <b>B</b>) doesn't exceed 200. A naive
  bruteforce strategy is to actually create the matrix and then iterate over all possible
  submatrices and calculate the sum for each submatrix. Since the number of submatrices is
  O(N<sup>4</sup>) (observe that for every pair of cells, there exists a unique submatrix), naively
  iterating over each submatrix in O(<i>submatrix size</i>) is bound to run for years(it's a
  whopping 1.2 * 10<sup>15</sup> operations for 20 test cases in the worst case). However, if we can
  calculate sum of each submatrix in constant time, the number of operations will reduce to
  3 * 10<sup>10</sup>, which is feasible for a modern machine in minutes.
</p>

<h4> Inclusion-exclusion to the rescue</h4>
<p>
  Quickly calculating submatrix sums of a matrix M can be done by maintaining another
  matrix P such that P(i, j) = sum of all cells M(a, b),
  such that 1 &le; a &le; i and 1 &le; b &le; j. Matrix P can be built in
  O(<i>size of</i> M) time by using the recurrence P(i, j) = M(i, j) + P(i-1, j) + P(i, j-1) -
  P(i-1, j-1). Note that the first three terms on the right hand side count some of the cells twice,
  which is why we subtract off the fourth term.
  Further, the sum of a submatrix defined by top-left and bottom-right cells (a, b) and (c, d) can be
  calculated as P(c, d) - P(a-1, d) - P(c, b-1) + P(a-1, b-1). Again, we add the last term on right
  hand side to accomodate the double subtraction of some cells.
</p>

<h3> A binary search large approach </h3>
<p>
  For the Large dataset, <b>N</b> could be up to 10<sup>5</sup>, which implies that creating the
  matrix in-memory is not possible, let alone iterating over all possible submatrices. We can,
  however, use the fact that M(i, j) = <b>A</b><sub>i</sub> *
  <b>B</b><sub>j</sub> to our advantage by expressing sum of cells in the submatrix defined
  by top-left and bottom-right cells (a, b) and (c, d), respectively, as
  (<b>A</b><sub>a</sub> + <b>A</b><sub>a+1</sub> + ... + <b>A</b><sub>c</sub>) *
  (<b>B</b><sub>b</sub> + <b>B</b><sub>b+1</sub> + ... + <b>B</b><sub>d</sub>),
  i.e., product of sum of contiguous subarrays of <b>A</b> and <b>B</b>.
</p>
<p>
  If we create two sorted lists U and V consisting of all possible subarray sums of <b>A</b> and
  <b>B</b>, respectively, we're trying to find the <b>K<sup>th</sup></b> largest value among
  U<sub>i</sub> * V<sub>j</sub> for all i, j.
  At this moment, we can exploit the fact that <b>K</b> doesn't exceed 10<sup>5</sup> by observing
  that we don't need to consider all possible values in U and V. We can work with the <b>K</b> largest
  and smallest values from both arrays(why the smallest? don't forget we also have negative values?)
  and be guaranteed that answer will be present in product of these values. At this point,
  we face two subproblems to finally solve this problem.
</p>
<h4> Subproblem 1</h4>
<p>
  Given an array <b>A</b> of size <b>N</b>, find the <b>K</b> largest subarray sums of <b>A</b>.
  Note that the value of <b>K</b> is approximately O(<b>N</b>). If we can do this, finding the <b>K</b>
  smallest subarray sums is easy by reversing the signs of values in A and running the same algorithm.
</p>
<h4> Solution</h4>
<p>
  We use binary search! The idea is to first find the <b>K<sup>th</sup></b> largest subarray sum
  by binary searching for it, and then build the actual subarray sums. To apply binary search for
  the <b>K<sup>th</sup></b> largest subarray sum, we need a function which can quickly count:
  how many subarray sums are less than X, for a given X?<br/>
  Let us define P<sub>i</sub> as sum of the first i
  elements of array <b>A</b>. Now, a simple idea is to iterate over i and
  fix the subarray start at position i. Now, we're trying to count
  possible j(&ge; i) such that
  P<sub>j</sub> &ge; P<sub>i</sub> + X.
  Note that the right size of the inequality is a constant for a fixed i.
  Things would've been easier if prefix sum array P had been an increasing sequence.
  However, that is not the case, since there are also negative values in array <b>A</b>.
  Suppose that we iterate over i from <b>N</b> to 1. At each step, we'll try to calculate
  the answer for i(which depends on all values <b>A</b><sub>j</sub> such
  that j &ge; i). Imagine we have a data structure DS
  which supports two operations:<br/>
  <ol>
    <li>Insert y : inserts y in the data structure.</li>
    <li>Query y : returns the count of values present in data structure that are less than
      or equal to y.</li>
  </ol>
  Using this DS, our job can be done(we can do DS.Insert(<b>A</b><sub>i</sub>),
  add DS.Query(P<sub>i</sub> + X) to our answer, and then decrement i and
  so on).
  Such a data structure can be implemented efficiently using any balanced binary search trees such
  as splay trees. Such trees can handle both operations in O(log(<i>size of DS</i>)).
  If the same data structure can support iterating over all values present in it in increasing order,
  we can get all subarray sums less than the <b>K<sup>th</sup></b> smallest subarray sum in a similar way.
  Note that we don't need the "Query" operation for doing this. So, the complexity of solving this
  subproblem turns out to be O(log(<i>range of answer</i>) * <b>N</b> * log(<b>N</b>) + <b>K</b>).
</p>
<h4> Subproblem 2</h4>
<p>
  Given two arrays <b>A</b> and <b>B</b> of size O(<b>N</b>), find the <b>K<sup>th</sup></b>
  largest among all possible values <b>A</b><sub>i</sub> *
  <b>B</b><sub>j</sub>, for all i, j.
</p>
<h4> Solution</h4>
<p>
  Again, we can use binary search on our answer if we, given X, can count how many pairs
  i, j exist such that <b>A</b><sub>i</sub> *
  <b>B</b><sub>j</sub> &ge; X.<br/>
  Just as in to subproblem 1, the idea is to iterate over i, and then count all
  possible j such that
  <b>B</b><sub>j</sub> &ge; X /  <b>A</b><sub>i</sub>,
  which is easily doable using binary search if array <b>B</b> is kept in a sorted fashion.
  However, note that it is a little trickier because of negative values. The complexity of solving this
  subproblem turns out to be (log(<i>range of answer</i>) * <b>N</b> * log(<b>N</b>)).
</p>


  <div class="test-data-download-wrapper">
    <div class="test-data-download-header">
      <div class="test-data-download-header-text">Test Data</div>
      <div class="test-data-download-header-download-button">
        <a href="test_data.zip" target="_blank">
          <i class="material-icons grey">save_alt</i>
        </a>
      </div>
    </div>
    <div class="test-data-download-content">
      <div class="test-data-download-warning">
        <span class="material-icons" style="color: grey; vertical-align: middle;">info</span>
        <span style="vertical-align: middle;">We recommend that you practice debugging solutions without looking at the test data.</span>
      </div>
    </div>
  </div>


    </div>
  </body>
</html>
