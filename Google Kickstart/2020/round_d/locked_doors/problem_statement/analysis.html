
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Kick Start 2020 - Round D</h3><h1>Analysis: Locked Doors</h1><h3>
Test Set 1
</h3>
<p>
  We can say that the rooms which Bangles has covered in the journey
  will always form a contiguous subarray. This is because, to go from room i to room j, Bangles must have unlocked the doors that
  occur between room i and room j once, only then Bangles would be able to move to room j. At any point of time, if Bangles has
  visited rooms from l to r, Bangles need to make a decision whether to go from room r to r+1 or from room l to l-1 depending which door has
  lower difficulty. Accordingly, Bangles can update l and r. For deciding which room to go next, it would take constant time. Thus, for taking <b>K</b>
  pictures, it would take O(<b>K</b>) time. <b>K</b> can be at most <b>N</b>. For each query, it would take O(<b>N</b>) time to process the query. Thus, overall complexity
  of the solution would be O(<b>Q</b> * <b>N</b>).
</p>

<h3>
Test Set 2
</h3>
<p>
  The naive solution would time out for the constraints of test set 2.
  Thus, we can use the following approach to solve this:
</p>
<p>
  Let InterestingLeft[i] be the door which is the closest door to the left of door i and has
  difficulty higher than door i. In case there is no such door, assign -1 to it.
  Similarly, let InterestingRight[i] be the door which is the closest door to the right of door i
  and has difficulty higher than door i. In case there is no such door, assign -1 to it.
  InterestingLeft[i] and InterestingRight[i] can be calculated by using the
  <a href="https://www.geeksforgeeks.org/find-the-nearest-smaller-numbers-on-left-side-in-an-array/">stack method</a>
  in O(<b>N</b>) time.
</p>
<p>
  After we are done unlocking the door i and all doors with difficulty lower than <b>D</b>[i] between
  doors InterestingLeft[i] and InterestingRight[i], we would either unlock door InterestingLeft[i] or
  door InterestingRight[i] next depending on which one has lower
  difficulty. If we have have only one choice, then we unlock that door itself.
  For generality, let us assume the next door that would be unlocked would be j. j would be equal to either InterestingLeft[i]
  or InterestingRight[i].
</p>
<p>
  Let us construct a tree using the given relations. For each door i, we find such j and assign j as parent of i. We can see that a node
  can have at most 2 children: at most one from the left side and at most one from the right side. Thus the relations would form a Cartesian tree.
  From the given tree, we can make the following observations:
</p>
<p>
  <ul>
    <li>If a node has only one child:
      <ul>
        <li>If the starting node is inside the subtree of current node, then the node will be visited only after all the nodes in its subtree have been visited.</li>
        <li>If the starting node is outside the subtree of current node, then first the node will be visited and after that the nodes in its subtree will be visited.</li>
      </ul>
    </li>
    <li>If a node has two children:
      <ul>
        <li>If the starting node is in left subtree, then first all the nodes in subtree of left child will be visited, then
    the current node will be visited, and finally the subtree of right child will be visited.</li>
        <li>Similarly, if the starting node is in right subtree, then first all the nodes in subtree of right child will be visited, then
    the current node will be visited, and finally the subtree of left child will be visited.</li>
      </ul>
    </li>
  </ul>
</p>
<p>
Building this tree can be done in O(<b>N</b>) time because assigning the parents for each node according
to InterestingLeft[i] and InterestingRight[i] takes constant time.
</p>

<p>
  Let the subtree size of node i be Size[i]. Consider a query with starting room <b>S</b> and we need to find <b>K</b>-th room we will be in.
  Let the starting door X be the first door that we unlock. This can be determined in constant time by comparing the doors adjacent to room <b>S</b>.
  In the constructed tree, if size[X] &lt; <b>K</b>, the whole subtree will be visited and we will move to its parent node.
  This will continue until we reach the node u such that size[u] &ge; <b>K</b>, so that we know that our answer lies within this subtree.
  To find such node, we can use the binary lifting approach similar to finding the
  <a href="https://www.geeksforgeeks.org/lca-in-a-tree-using-binary-lifting-technique/">lowest common ancestor between two nodes in a tree</a>.
  This can be precomputed in O(<b>N</b> * log(<b>N</b>)) time.
  In a query we have following cases:
</p>
<p>
  <ul>
    <li>If size[X] &ge; <b>K</b>, then:
      <ul>
        <li>If X is the door left to <b>S</b>, then answer is <b>S</b> - <b>K</b>.</li>
        <li>Otherwise, answer is <b>S</b>+<b>K.</b></li>
      </ul>
    </li>
    <li>Otherwise, find node Y which is the first node on path from X to root such that size[Y] &ge; <b>K</b>.
      This can be done using binary lifting in O(log<b>N</b>). Now we can find the answer in constant time as follows:
      <ul>
        <li>If X &lt; Y, then answer is Y + <b>K</b> - size[leftChild[Y]]</li>
        <li>Otherwise, answer is Y + 1 - (<b>K</b> - size[rightChild[Y]])</li>
      </ul>
    </li>
  </ul>
</p>

<p>
  Each query takes O(log<b>N</b>) time and building the binary tree and preprocessing for binary lifting takes O(<b>N</b> log<b>N</b>) time.
  Hence, overall complexity of the solution is O(<b>N</b> log<b>N</b> + <b>Q</b> log<b>N</b>).
</p>


  <div class="test-data-download-wrapper">
    <div class="test-data-download-header">
      <div class="test-data-download-header-text">Test Data</div>
      <div class="test-data-download-header-download-button">
        <a href="test_data.zip" target="_blank">
          <i class="material-icons grey">save_alt</i>
        </a>
      </div>
    </div>
    <div class="test-data-download-content">
      <div class="test-data-download-warning">
        <span class="material-icons" style="color: grey; vertical-align: middle;">info</span>
        <span style="vertical-align: middle;">We recommend that you practice debugging solutions without looking at the test data.</span>
      </div>
    </div>
  </div>


    </div>
  </body>
</html>
