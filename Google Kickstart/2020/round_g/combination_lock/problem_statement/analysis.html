
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Kick Start 2020 - Round G</h3><h1>Analysis: Combination Lock</h1><p>
  We can see that if we decide a final value at which all wheels should be in the end, moves for each wheel
  to reach that value are independent of the moves performed on other wheels. Thus, we can calculate number of moves for each wheel separately.
  Consider a wheel i which is at value x currently. We want the wheel to finally reach the value y. There are 2 cases here:
  <ul>
    <li>
      Case 1: x &le; y. Increasing the value of the wheel i would take y-x steps. Decreasing the value
      of wheel i would take <b>N</b> - y + x steps. Hence, the minimum number of moves in this case would be minimum of y-x and <b>N</b> - y + x.
    </li>
    <li>
      Case 2: x &gt; y. Decreasing the value of the wheel i would take x-y steps. Increasing the value
      of wheel i would take <b>N</b> + y - x steps. Hence, the minimum number of moves in this case would be minimum of x-y and <b>N</b> + y - x.
    </li>
</ul>
</p>

<h3>
Test Set 1
</h3>

<p>
  We can solve this test set by trying all possible <b>N</b> values that all the wheels should have in the end. For each value, we
  calculate the total number of moves to get all of the wheels to this value using Case 1 and Case 2. The answer is the minimum possible
  moves performed over all such X.
  There are <b>N</b> possible values and for each value, we perform O(<b>W</b>) operations.
  Thus, the time complexity of the solution would be O(<b>W</b> &times; <b>N</b>).
</p>

<h3>
Test Set 2
</h3>

<p>
  A major observation is that we could always get the minimum possible moves by finally bringing all the wheels to one of the
  initial values of the given wheels. We can prove this by considering a value Val which is not among the initial values
  of wheels and then showing that we can get a same or better answer by moving all the wheels to one of the initial values. Consider the initial
  values of the wheels in the sorted order. Let the index of the wheel with
  smallest initial value greater than Val be j, if no such value exists, then we can consider j &equals; 1 as it is first wheel next to value Val in cyclic order.
  Let the index of wheel with largest initial value smaller than Val be i, if no such value exists, then we can consider i &equals; <b>W</b> as it is the first wheel before value Val in cyclic order. Now to reach the value Val,
  each value will either reach <b>X<sub>i</sub></b> or <b>X<sub>j</sub></b>. Now say there are y wheels at value <b>X<sub>i</sub></b> currently which
  leaves us with <b>W</b> - y wheels at value <b>X<sub>j</sub></b>. The number of moves for all wheels to reach value Val would be
  y &times; (Val - <b>X<sub>i</sub></b>) + (<b>W</b> - y) &times; (<b>X<sub>j</sub></b> - Val). We can get the same or better result than this.
  There are 2 possibilities:
  <ul>
    <li>
      y &le; <b>W</b> - y. If we choose to bring all the wheels to value <b>X<sub>j</sub></b>, we will have number of moves
      as y &times; (Val - <b>X<sub>i</sub></b>) + y &times; (<b>X<sub>j</sub></b> - Val), which is never large than the number of moves required for all wheels to
      reach value Val. Hence, we have a better answer if we bring all the wheels to value <b>X<sub>j</sub></b>.
    </li>
    <li>
      y &ge; <b>W</b> - y. If we choose to bring all the wheels to value <b>X<sub>i</sub></b>, we will have number of moves
      as (<b>W</b> - y) &times; (Val - <b>X<sub>i</sub></b>) + (<b>W</b> - y) &times; (<b>X<sub>j</sub></b> - Val), which is never large than the number of moves required for
      all wheels to reach value Val. Hence, we have a better answer if we bring all the wheels to value <b>X<sub>i</sub></b>.
    </li>
  </ul>
</p>

<p>
  Now instead of trying all possible values from 1 to <b>N</b>, we would try the initial values of the wheels and calculate
  moves required for all wheels to reach that value. For each value, we take O(<b>W</b>) time to calculate the moves required for all wheels to reach that
  value. There are <b>W</b> values. Hence the complexity is O(<b>W</b><sup>2</sup>).
</p>

<h3>
Test Set 3
</h3>

<p>
  We have already proved that we only need to consider one of the initial values of the wheels. We need to calculate the number of moves required for
  all wheels to reach a particular value efficiently. We can do the following. Sort the initial values of the wheels. Maintain a prefix sum array Pre.
  Pre[i] denotes the sum of initial values of wheels from 1 to i. We define a method GetSum(i,j) which gives the sum of values between indexes i
  and j. This can be calulated in O(1) using Pre array.
</p>

<p>
  Suppose that currently we are calulating the number of moves required for all wheels
  to reach <b>X<sub>i</sub></b>. Consider any wheel j from index 1 to i. Minimum number of moves required for wheel j to reach value
  <b>X<sub>i</sub></b> would be minimum of <b>X<sub>i</sub></b> - <b>X<sub>j</sub></b> and <b>N</b> - <b>X<sub>i</sub></b> + <b>X<sub>j</sub></b>.
  Consider 2 indexes k and l such that 1 &le; k &lt; l &le; i. We can prove that it is not possible to have
  <b>X<sub>i</sub></b> - <b>X<sub>k</sub></b> &lt; <b>N</b> - <b>X<sub>i</sub></b> + <b>X<sub>k</sub></b> and
  <b>N</b> - <b>X<sub>i</sub></b> + <b>X<sub>l</sub></b> &lt; <b>X<sub>i</sub></b> - <b>X<sub>l</sub></b>
  simultaneously. This is because if we add the two inequalities, we get <b>N</b> - <b>X<sub>k</sub></b> + <b>X<sub>l</sub></b>
  &lt; <b>N</b> + <b>X<sub>k</sub></b> - <b>X<sub>l</sub></b> which implies
  <b>X<sub>l</sub></b> &lt; <b>X<sub>k</sub></b>. But it is not possible to have such condition because we know
  that <b>X<sub>k</sub></b> &le; <b>X<sub>l</sub></b>.
  Thus, we can say that there exists an index p such that 1 &le; p &le; i and for each wheel q such that p &le; q &le; i
  will have minimum number of moves as <b>X<sub>i</sub></b> - <b>X<sub>q</sub></b> and for each wheel r such that 1 &le; r &le; p-1
  will have minimum number of moves as <b>N</b> - <b>X<sub>i</sub></b> + <b>X<sub>r</sub></b>.
  We can find this index p using binary search on wheels 1 to i. Now we need to find sum of <b>X<sub>i</sub></b> - <b>X<sub>q</sub></b> for each q.
  This can be calculated in O(1) by (i - p + 1) &times; <b>X<sub>i</sub></b> - GetSum(p,i).
  Now we need to find sum of <b>N</b> - <b>X<sub>i</sub></b> + <b>X<sub>r</sub></b> for each r. This can be calculated in O(1)
  by (p-1) &times; (<b>N</b> - <b>X<sub>i</sub></b>) + GetSum(1,p-1). We have calculated number of moves required for wheels 1 to i to reach value <b>X<sub>i</sub></b>.
</p>

<p>
  Similarly, we can say that there exists an index b such that i &le; b &le; <b>W</b> and for each wheel c such that i &le; c &le; b
  will have the minimum number of moves as <b>X<sub>c</sub></b> - <b>X<sub>i</sub></b> and for each wheel d such that b+1 &le; d &le; <b>W</b>
  will have the minimum number of moves as <b>N</b> - <b>X<sub>d</sub></b> + <b>X<sub>i</sub></b>.
  We can find this index b by using binary search on wheels 1 to <b>W</b>. Now we need to find sum of <b>X<sub>c</sub></b> - <b>X<sub>i</sub></b> for each c.
  This can be calculated in O(1) by GetSum(i+1,c) - (c-i) &times; <b>X<sub>i</sub></b>.
  Now we need to find sum of <b>N</b> - <b>X<sub>d</sub></b> + <b>X<sub>i</sub></b> for each d. This can be calculated in O(1)
  by (<b>W</b> - b) &times; (<b>N</b> + <b>X<sub>i</sub></b>) - GetSum(b+1,<b>W</b>).
</p>

<p>
   We have calculated the number of moves required for all wheels to reach a particular value in O(log <b>W</b>). Now we need to take the minimum over all such values. Thus we can calculate moves for all the initial values
  of all wheels in O(<b>W</b> &times; log <b>W</b>) time complexity. Note that instead of using binary search to find indexes p and b, we can
  use two pointers approach to find them. We can prove that indexes p and b will keep on increasing as we increment i. The overall complexity
  of the solution remains same due to the sorting part.
</p>


  <div class="test-data-download-wrapper">
    <div class="test-data-download-header">
      <div class="test-data-download-header-text">Test Data</div>
      <div class="test-data-download-header-download-button">
        <a href="test_data.zip" target="_blank">
          <i class="material-icons grey">save_alt</i>
        </a>
      </div>
    </div>
    <div class="test-data-download-content">
      <div class="test-data-download-warning">
        <span class="material-icons" style="color: grey; vertical-align: middle;">info</span>
        <span style="vertical-align: middle;">We recommend that you practice debugging solutions without looking at the test data.</span>
      </div>
    </div>
  </div>


    </div>
  </body>
</html>
