
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Code Jam 2016 - Round 2</h3><h1>Analysis: The Gardener of Seville</h1><h2>The Gardener of Seville: Analysis<h2>
<h3>Small dataset</h3>
<p>
For the Small dataset, there are at most 16 cells in the courtyard that we must
assign hedge directions to, a total of at most 65536 different hedge mazes.
Note that because every cell must have a diagonal hedge, any maze creates a
bijection between courtiers; it is impossible for the paths used by two
different pairs of lovers to intersect, so we don't need to worry about that.
We can use brute force to generate and check all possible hedge mazes, as long as
we can efficiently work out which outer cells are paired up through the hedge
maze. This can be done in various ways, including:
<ul><li>Consider hedges to be mirrors, and imagine shining a beam of light into
the maze from an outer cell, perpendicular to the edge it's on. At each cell
the light will reflect off the cell's mirror at a 90 degree angle and continue
to the next cell in its new direction. It repeatedly bounces off mirrors until
it exits the maze at the cell it's paired with.</li>
<li>Imagine drawing both hedges in each cell, splitting each cell into four
quadrants. We can represent the maze as a graph in which the nodes are these
quadrants, and there are edges between adjacent quadrants that are not blocked
by part of a hedge. We can find which courtiers are paired by starting at the
node corresponding to that courtier's starting edge of the maze, and traversing
the graph until we reach another edge. Equivalently, we can find the connected
components of the graph.</li></ul>
</p>
<h3>Large dataset</h3>
<p>
The Large dataset has test cases with up to 100 cells, which is too large for our
brute force approach. A more fruitful approach is to take the given pairs
and install hedges so that those pairs are connected. The easiest cases would be
connecting two cells which are adjacent (either along an edge or around a
corner). For example, to connect the two outer cells adjacent to the upper left
corner, a single <code>/</code> hedge is sufficient. Does it ever make sense to
connect them any other way? The illustration for test case 3 from the sample input
connects the two outer cells adjacent to the upper right corner via a longer
winding path, but it would also work to make this connection direct and leave the
center of the garden unreachable. The direct
connection covers just two triangular quadrants (as defined in the Small dataset
section) in the corner, and it is easy to see that any other possible path
between the two cells also covers these two quadrants. Thus there is no reason
not to use this direct path if we need to connect the cells at a corner.
</p><p>
How about outer cells next to each other along an edge? These can be easily
connected using two hedges, which covers four triangular quadrants. All possible
connections will necessarily cover the two quadrants at the edge of the board,
but we can construct paths which do not cover the other two quadrants. However,
any path that does not use those two quadrants is guaranteed to block them off
and make them inaccessible from other edges. Thus, any path between the two cells
will either cover the four quadrants forming the simplest path, or render some of
them unusable; there is no reason to use anything more complex than the simplest path.
</p><p>
If every pair to connect has a similarly optimal path which we can easily
determine, then we can solve the problem by installing hedges so each pair is
connected via its respective optimal path, and if any of the paths intersect
then there is no solution. Consider, however, a pair between outer cells on the left
and right sides of the garden. Depending on the other connections we need to
make, we may be able to freely choose between (for example) having the path go
through the top half of the garden and the bottom half of the garden. As such,
there isn't a clear single optimal path for connecting this pair. However, we
can consider uppermost and lowermost paths, which leave the most space for
paths below and above them, respectively. For an uppermost path, for example, we want to take
the least space possible to connect the pair, and all the pairs above it.
turns out there is a optimal way to connect such pairs.
</p><p>
For the rest of the analysis, we will assume that there is a solution to the
problem. If there is a solution, then our strategy will provide a way to find
it. If there is no solution, our strategy may not be correct but we can easily
detect that it fails by checking the hedge maze as we did in the Small solution.
</p><p>
Define a 'group of pairs' as a non-zero number of pairs where all the outer cells used
form a fully contiguous section around the perimeter (but not the full perimeter).
For a pair connecting the left and right sides of the garden, we can consider
the group of pairs above the path connecting this pair, and the group of pairs
above and including this pair. Every group of pairs has an optimal set of
triangular quadrants to join all pairs in that section. Similar to before,
optimality here means that we can install hedges to connect each pair in the
group without covering quadrants outside the optimal set (this property is
sufficiency), and if all pairs in the group are connected, no paths from other
pairs can ever cover quadrants inside the set (this property is necessity).
</p><p>
We already know the optimal sets for the groups with a single pair of adjacent
outer cells. If we have two groups of pairs, which together would form a larger
group of pairs, the optimal set will be the union of the optimal sets for the
two smaller groups. We can prove that this meets both the sufficiency and
necessity properties (as stated before, this requires the assumption that there
is a solution).
</p><p>
Consider again the case of a pair connecting the left and right sides of the
garden. If we have the optimal set for the group of pairs above this pair, then
we can try and extend this to the optimal set for the group of pairs above and
including this pair. It makes sense to try and make the path for this pair as
high up as possible, staying as close as possible to the paths above it. It can
be proven that including this path makes a new optimal set. In general, this
works for any non-adjacent pair. If we have the optimal set of quadrants for
the group of pairs on one side of a pair, we can extend it by adding a path
that stays as close to those quadrants as possible. This means we can
inductively find optimal sets of quadrants until we cover all the pairs (note
that we did not define all pairs as a valid group of pairs, as the definition
of optimality doesn't work for that case).
</p><p>
These ideas give us the following algorithm:
<ul>
<li>Start with no hedges in the garden</li>
<li>Iterate over pairs, in increasing order of distance (along the perimeter)
between the two cells. Ties can be broken arbitrarily.
<ul><li>Let the two outer cells be A and B, such that A&rarr;B clockwise around
the edge is shorter than counterclockwise. Due to the chosen iteration order,
we've already built paths for all points on the left side of the A&rarr;B path
we're going to construct.</li>
<li>Walk through maze starting at A (the mirror analogy is useful here). We want
to stay to the left as much as possible, so if we get to a cell without a hedge
installed we pick one so that we turn left. Once we exit the maze, check if we
actually made it to B. (If there is no solution we might end up somewhere else.)
</li></ul>
<li>Fill in remaining cells arbitrarily</li>
</ul>
</p><p>
A sample implementation of this in Python is provided below. We encode
directions with integers, which allows us to rotate direction and calculation
movement easily using bitwise operations and array lookups.
</p><pre><code>def position(v, R, C):
    # Map from outer cell number to a direction facing into the maze
    # and the position of the outer cell
    # 0->downwards, 1->leftwards, 2->upwards, 3->rightwards
    if v &lt;= C: return 0, v-1, -1
    v -= C
    if v &lt;= R: return 1, C, v-1
    v -= R
    if v &lt;= C: return 2, C-v, R
    v -= C
    return 3, -1, R-v

def move(x, y, direction):
    return x + [0,-1,0,1][direction], y + [1,0,-1,0][direction]

def solve(R, C, permutation):
    board = [[None] * C for _ in range(R)]
    size = 2*(R+C)
    permutation = zip(permutation[::2], permutation[1::2])
    permutation.sort(key=lambda(a,b): min((b-a)%size, (a-b)%size))
    for start, end in permutation:
        if (start-end) % size > R+C:
            start, end = end, start
        direction, x, y = position(start, R, C)
        x, y = move(x, y, direction)
        while 0&lt;=x&lt;C and 0&lt;=y&lt;R:
            if board[y][x] is None:
                board[y][x] = "/\\"[direction &amp; 1]
            direction ^= {"/": 1, "\\": 3}[board[y][x]]
            x, y = move(x, y, direction)
        if (x, y) != position(end, R, C)[1:]:
            return "IMPOSSIBLE"
    return "\n".join("".join(c or "/" for c in row) for row in board)

if __name__ == "__main__":
    for t in range(1, input() + 1):
        R, C = map(int, raw_input().split())
        permutation = map(int, raw_input().split())
        print "Case #%d:" % t
        print solve(R, C, permutation)</code></pre>


  <div class="test-data-download-wrapper">
    <div class="test-data-download-header">
      <div class="test-data-download-header-text">Test Data</div>
      <div class="test-data-download-header-download-button">
        <a href="test_data.zip" target="_blank">
          <i class="material-icons grey">save_alt</i>
        </a>
      </div>
    </div>
    <div class="test-data-download-content">
      <div class="test-data-download-warning">
        <span class="material-icons" style="color: grey; vertical-align: middle;">info</span>
        <span style="vertical-align: middle;">We recommend that you practice debugging solutions without looking at the test data.</span>
      </div>
    </div>
  </div>



    </div>
  </body>
</html>
