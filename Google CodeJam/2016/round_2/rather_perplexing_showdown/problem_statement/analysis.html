
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Code Jam 2016 - Round 2</h3><h1>Analysis: Rather Perplexing Showdown</h1><h2>Rather Perplexing Showdown: Analysis</h2>
<p>
There are multiple ways to attack this problem. We will present two methods for
building the correct tournament tree, and a method for finding the arrangement
of that tree that produces the alphabetically earliest lineup. It is possible
to combine the tree building and tree optimization methods into a single
algorithm, but we present the analysis this way for ease of explanation.
</p>
<h3>Building the tree: starting from the beginning</h3>
<p>
Let's start from the beginning of the tournament and create each new round. At
any point, you have some number of <code>R</code>s, <code>P</code>s, and
<code>S</code>s remaining, and you can only create <code>RP</code>,
<code>RS</code>, and <code>PS</code> matches, because anything else would
result in a tie. Call the number of <code>RP</code> matches you will create
<i>x</i> &mdash; that is, you will make <i>x</i> of the <code>R</code>s match
up with <code>x</code> of the <code>P</code>s. Then all other <code>R</code>s
must face <code>S</code>s, so you will create <b>R</b>-<i>x</i> <code>RS</code>
matches. There will be <b>P</b>-<i>x</i> leftover <code>P</code>s and
<b>S</b>-(<b>R</b>-<i>x</i>) leftover <b>S</b>s, and these numbers must be
equal to avoid creating tied matches, so <b>P</b>-<i>x</i> =
<b>S</b>-<b>R</b>+<i>x</i> and <i>x</i> = (<b>R</b>+<b>P</b>-<b>S</b>)/2. If
this <i>x</i> causes an impossible situation (e.g, there must be more
<code>RP</code> matches than there are <code>R</code>s or <code>P</code>s),
then the answer is <code>IMPOSSIBLE</code>. Otherwise, match the players
accordingly, note the winners (all <code>RP</code>s become <code>P</code>s, all
<code>RS</code>s become <code>R</code>s, and all <code>PS</code>s become
<code>S</code>s), and then you have a smaller instance of the same problem.
This strategy tells you whether the tournament will end, and how to make all
your matchups; with that information and some careful bookkeeping along the
way, you can generate the entire tree.
</p><p>
<h3>Building the tree: starting from the end</h3>
<p>
Let's start from the end of a tournament instead. Suppose that the winning
player is a <code>P</code>. What do we know about the match that produced
that winner? One of the participants must have been that <code>P</code>, and
the other must have been the opponent that the <code>P</code> defeated, namely,
an <code>R</code>. That <code>R</code> must have defeated an <code>S</code>,
and so on. That is, for any node in the tournament tree, including the bottom
(winning) node, we can easily regenerate the entire part of the tree that led
to it!
</p><p>
This also implies that for a given <b>N</b>, there is only one possible
(<code>R</code>, <code>P</code>, <code>S</code>) triplet that will produce a
successful tournament ending in <code>R</code>, and likewise for <code>P</code>
and <code>S</code>. Almost all triplets are doomed to fail! There are only
three valid ones for any <b>N</b>, and each of them must produce a different
winner.
</p><p>
So, we can try all three possible winners (<code>R</code>, <code>P</code>, and
<code>S</code>) for every value of <b>N</b> from 1 to 12, and store the
resulting tournament trees and their numbers of <code>R</code>s,
<code>P</code>s, and <code>S</code>s. Then, for each test case, either the
given <b>N</b>, <b>R</b>, <b>P</b>, and <b>S</b> values match one of the stored
trees, or we know the case is <code>IMPOSSIBLE</code>.
</p>
<h3>Finding the alphabetically earliest lineup</h3>
<p>
Having the tournament tree is not enough, because a tree can generate many
possible lineups. For any internal (non-leaf) node in the tree, you can swap
the two branches; this does not change the tree, but it does change the initial
lineup! For instance, the lineups <code>PSRS</code>, <code>PSSR</code>,
<code>RSPS</code>, <code>RSSP</code>, <code>SPRS</code>, <code>SPSR</code>,
<code>SRPS</code>, and <code>SRSP</code> all represent the same tree. There are
2<sup><b>N</b></sup>-1 internal nodes in the tree, and we can't try all 2 to
the (2<sup><b>N</b></sup>-1) ways of flipping or not flipping each of them.
Fortunately, we don't have to.
</p><p>
Consider any pair of players who face off in the first round; let's say
they're using moves X and Y, where X is alphabetically earlier than Y. These
two players will contribute to two consecutive characters in the lineup;
either XY or YX, depending on whether we flip their node. Flipping other nodes
in the tree may move this pair of characters around in the final lineup, but it
cannot reverse or separate them. So we have nothing to lose by choosing XY;
this decision is totally independent of whatever we do with other nodes later.
More generally, for any node, we should put the "alphabetically earlier" branch
before the "alphabetically later" branch. Moreover, we should optimize
shallower nodes in the tree before optimizing deeper nodes, so that we can be
sure that we're only making decisions about branches that are already
themselves alphabetically optimized.
</p><p>
So we can start with <i>any</i> lineup corresponding to our tree (ideally,
whatever came out of our algorithm earlier), and first examine the lineup in
2<sup><b>N</b>-1</sup> chunks of length 2 and swap the letters in each chunk
whenever that would make the chunk alphabetically earlier. Then we can examine
the lineup in 2<sup><b>N</b>-2</sup> chunks of length 4, and swap the subchunks
of length 2 in each chunk whever that would make the chunk alphabetically
earlier. And so on, until we've examined and possibly swapped the 2 chunks of
length 2<sup><b>N</b>-1</sup>; that final lineup will be our alphabetically
earliest answer.
</p><p>


  <div class="test-data-download-wrapper">
    <div class="test-data-download-header">
      <div class="test-data-download-header-text">Test Data</div>
      <div class="test-data-download-header-download-button">
        <a href="test_data.zip" target="_blank">
          <i class="material-icons grey">save_alt</i>
        </a>
      </div>
    </div>
    <div class="test-data-download-content">
      <div class="test-data-download-warning">
        <span class="material-icons" style="color: grey; vertical-align: middle;">info</span>
        <span style="vertical-align: middle;">We recommend that you practice debugging solutions without looking at the test data.</span>
      </div>
    </div>
  </div>



    </div>
  </body>
</html>
