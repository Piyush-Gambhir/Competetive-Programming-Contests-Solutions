
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Code Jam 2016 - Round 2</h3><h1>Analysis: Freeform Factory</h1><p>As the first step in solving this problem, we will move it from worker/factory terms to graph
  terms: we are given a bipartite graph with <b>N</b> vertices in each part, and need to add
  the smallest amount of edges to this graph to guarantee that every
  <a href="https://en.wikipedia.org/wiki/Matching_(graph_theory)#Definition">maximal matching</a>
  (one where it is impossible to add more edges) is a perfect matching (one which covers all vertices).

</p><p>In order to determine that, we need to understand which bipartite graphs have the property that
  every maximal matching is perfect. One can tackle this part by drawing a few
  graphs on paper and trying to add edges one by one to find a maximal matching.

</p><p>
  After a few experiments, we can form a hypothesis: every maximal matching is perfect if and
  only if each connected component of the bipartite graph is a
  <a href="https://en.wikipedia.org/wiki/Complete_bipartite_graph">complete bipartite graph</a>
  with same number of
  vertices in each part. The "if" part is somewhat clear, but the "only if" part
  looks surprising at first and definitely needs a formal proof, which you can find at the end of
  this editorial. Here's an example of such graph:<br/>
  <img src="ff_pic1.png">

</p><p>Now we can return to solving our problem. As the first step, we need to find the number
  of vertices in each half for each connected components of the graph. Let us put those
  numbers into a list of pairs, one pair per connected component:
  (<i>p</i><sub>1</sub>, <i>q</i><sub>1</sub>),
  (<i>p</i><sub>2</sub>, <i>q</i><sub>2</sub>), ...
  The above hypothesis tells us that we need to split this list into groups such
  that in each group the sum <i>r</i> of all <i>p</i>s equals the sum of all <i>q</i>s, those groups
  corresponding to the connected components of the graph after adding more edges.
  The number of added edges is the total number of edges in the resulting graph minus
  the number edges we have initially, and the number of edges in the resulting graph
  is equal to the sum of squares of <i>r</i>s. Thus we need to minimize the sum of squares of
  <i>r</i>s.

</p><p>Since <b>N</b> is quite small&nbsp;&mdash; up to 25&nbsp;&mdash; there are quite a few
  approaches that work, almost all revolving around dynamic programming/memoization.

</p><p>Here is one possibility:
  for each subset <i>Y</i> of the (multi-)set <i>X</i> of pairs we have,
  and each number <i>t</i> between 0 and <b>N</b>, we will check if it is possible to group
  all components in <i>Y</i> into groups in such a way that there are several balanced
  groups with total size <i>t</i>, and possibly one unbalanced group with all remaining
  components. In case it is possible, we will find the smallest possible sum of squares
  of sizes of the balanced groups, denoted as <i>dp</i><sub><i>Y</i>,<i>t</i></sub>.
  Looking at <i>dp</i><sub><i>X</i>,<b>N</b></sub> will give us the answer to the problem.

</p><p>At first sight,
  it seems that we are considering 2<sup>50</sup> subsets here as we might have up to 50 components
  in the original graph (if we have no edges at all), but we can note that equal components are
  interchangeable, so a graph with no edges simply has 25 components of one type and 25 components
  of the other type, and thus has the total of 26*26=676 different subsets of components.
  The maximum amount of different subsets of components for N=25 is 43008, formed by the following
  initial components:
  6&times;(0,1), 5&times;(1,0), 3&times;(1,1), 1&times;(1,2), 1&times;(1,3), 1&times;(1,4),
  1&times;(2,1), 1&times;(2,2), 1&times;(3,1), 1&times;(3,2), 1&times;(4,1).

</p><p>The most straightforward way to compute the <i>dp</i><sub><i>Y</i>,<i>t</i></sub> values
  is to use the so-called <i>forward dynamic programming</i>: after finding
  <i>dp</i><sub><i>Y</i>,<i>t</i></sub>, we will iterate over all ways to add a new element
  to the unbalanced group in <i>Y</i>, updating <i>t</i> in case the unbalanced group
  becomes balanced.
</p><p>All that is left is to prove the hypothesis. We will prove by contradiction: assume that
  the hypothesis is false&nbsp;&mdash; in other words, that there exists a bipartite graph
  where every maximal matching is perfect, but one of its connected components is not a complete
  bipartite graph with same number of vertices in each part.

</p><p>Consider such counterexample <i>G</i> with the smallest number of vertices (note that
  looking at the smallest counterexample is essentially the same as proving by induction). First of all,
  <i>G</i> is connected&nbsp;&mdash; otherwise any of its connected components would form a smaller
  counterexample. It is also clear that both its parts have the same number of vertices, as otherwise
  no perfect matching exists at all, while at least one maximal matching always exists, so we would have
  a contradiction. Since <i>G</i> is a counterexample, it is missing at least one edge. Let us
  say that the missing edge connects vertices <i>a</i> and <i>b</i>.

</p><p>
  Consider any edge (<i>a</i>, <i>c</i>) that exists from <i>a</i>
  (there is one since <i>G</i> is connected). Consider the graph <i>G</i>' obtained by
  removing <i>a</i>, <i>c</i> and all their incident edges from <i>G</i>. Every maximal matching
  in this smaller graph is perfect, since it can be extended to a maximal matching in
  <i>G</i> by adding (<i>a</i>, <i>c</i>). And since <i>G</i>' has fewer vertices
  than <i>G</i>, it is not a counterexample to our hypothesis, and thus each connected component
  of <i>G</i>' is a complete bipartite graph with same number of vertices in each part.

</p><p>Let us look at the connected component <i>H</i> of <i>G</i>' containing <i>b</i>. There are three
  cases, each leading to a contradiction:

</p><ul>
  <li>There is at least one edge (<i>d</i>, <i>c</i>) in <i>G</i> from <i>H</i> to <i>c</i>.
    Since all connected components of <i>G</i>' are complete, we can easily build a matching
    <i>M</i>'
    in <i>G</i>' that covers all vertices except <i>d</i> and <i>b</i>. By adding the edge
    (<i>d</i>, <i>c</i>) to this matching we get a matching <i>M</i> in <i>G</i>.
    Matching <i>M</i> is maximal: its only two uncovered vertices are <i>a</i> and <i>b</i>,
    and there is no edge between them. <i>M</i> is not perfect, and thus we get a contradiction
    with the definition of <i>G</i>.

  </li><li>There is no edge from <i>H</i> to <i>c</i>, but there exists an edge (<i>a</i>, <i>e</i>)
  from <i>a</i> to <i>H</i>. Consider any vertex <i>f</i> from <i>H</i> in a different part from
  <i>e</i>. Since <i>H</i> and all other connected components of <i>G</i>' are complete,
  we can now build a matching <i>M</i>' in <i>G</i>' that covers all vertices except
  <i>e</i> and <i>f</i>. By adding the edge (<i>a</i>, <i>e</i>) to this matching we get a matching
  <i>M</i> in <i>G</i>. Matching <i>M</i> is maximal: its only two uncovered vertices are
  <i>f</i> and <i>c</i>, and there is no edge between them since there is no edge between the entire
  <i>H</i> and <i>c</i>. <i>M</i> is not perfect, and thus we get a contradiction
    with the definition of <i>G</i>.

  </li><li>Finally, if <i>H</i> is not connected to <i>a</i> and <i>c</i>, then <i>G</i> is
    disconnected, which is also a contradiction.
  </li>
</ul><p>
The first two contradiction cases are depicted below:<br/>
<img src="ff_pic2.png">
</p>
<p>
There is also a more beautiful argument leading to a contradiction which does not even require
the counterexample <i>G</i> to be the smallest,
but it can be a bit harder to come up with. Since <i>G</i> is connected, there is a simple path
<i>P</i> between <i>a</i> and <i>b</i>. Since the graph is bipartite, <i>P</i> has odd length and
covers some subset
of the vertices, the same number from each part. We construct a maximal (therefore perfect) matching
as follows: we take every odd edge along the path <i>P</i>, and then complete it with arbitrary
edges. Now, we can change our choice of edges and take the even edges of <i>P</i> instead of the odd
ones. As a result, our matching has one less edge, and vertices <i>a</i> and <i>b</i> are the only
non-covered ones. Since a and b are not connected by an edge, we are left with a maximal matching
which is not perfect, in other words a contradiction.
</p>


  <div class="test-data-download-wrapper">
    <div class="test-data-download-header">
      <div class="test-data-download-header-text">Test Data</div>
      <div class="test-data-download-header-download-button">
        <a href="test_data.zip" target="_blank">
          <i class="material-icons grey">save_alt</i>
        </a>
      </div>
    </div>
    <div class="test-data-download-content">
      <div class="test-data-download-warning">
        <span class="material-icons" style="color: grey; vertical-align: middle;">info</span>
        <span style="vertical-align: middle;">We recommend that you practice debugging solutions without looking at the test data.</span>
      </div>
    </div>
  </div>



    </div>
  </body>
</html>
