
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Code Jam 2016 - World Finals</h3><h1>Analysis: Map Reduce</h1><h2>Map Reduce: Analysis</h2>
<h3>Some initial checks</h3>
<p>
First, calculate two values: the length L<sub>i</sub> of any shortest path from
the start to the finish (using
<a href="https://en.wikipedia.org/wiki/Breadth-first_search">BFS</a>), and the
<a href="https://en.wikipedia.org/wiki/Taxicab_geometry">Manhattan distance</a>
M from the start to the finish (ignoring walls). Based on those results, we can
immediately detect some impossible cases:
</p>
<ul>
<li>We can only remove walls, so we have no way to <i>increase</i> the length
of the shortest path above L<sub>i</sub>. So, if L<sub>i</sub> is less than
<b>D</b>, there is no solution.</li>
<li>Similarly, if M is greater than <b>D</b>, removing walls does not help;
even a blank maze consisting of only a border would still have a shortest path
length &gt; <b>D</b>.</li>
<li>If the parity of L<sub>i</sub> and <b>D</b> is different, there is no
solution. The lengths of all paths between any two given cells have the same
parity, because each step flips the parity of the sum of the indices of the row
and column.
</li>
</ul></p>
<p>
Surprisingly, in any other case, there is always a solution. The rest of
the problem is to provide a constructive proof of that fact.
</p>
<h3>A crucial observation</h3>
<p>
We want to remove walls to change the current shortest path length L to match
<b>D</b>. The key to solving this problem is to notice that we can always
remove a wall such that the new shortest path has a length of either L or L-2.
The proof of this is somewhat difficult, but we can discuss it intuitively (a
formal proof follows at the end of this analysis).
</p><p>
Consider a connected component of walls. It either includes the border or it
doesn't. Now, pick some wall W within that connected component that is as far
as possible away from either the border, or some arbitrary wall within the
component if it doesn't include the border. Using the fact that all empty
spaces are connected and that no two walls can connect at a corner, we can find
that the 3&times;3 neighborhood of W looks like one of the following cases,
up to symmetry (<code>#</code> is a wall, <code>.</code> is a space,
<code>?</code> can be either):
</p>
<pre>
...  ?#?  ?##
.W.  .W.  .W#
...  ...  ..?
</pre>
<p>
Let's consider each case in turn. We will show that if the shortest path
proceeded through the 3&times;3 neighborhood of W, removing W will decrease the
length of the shortest path by at most 2:
</p>
<ul>
<li><i>W has zero neighbors that are walls</i>: The only path that would be
  shortened by removing W is a path that goes around W. So, removing W will
  shorten the path by 2, since the path can now go directly through W.</li>
<li><i>W has one neighbor that is a wall</i>: Say we have the case pictured
  above, and the shortest path proceeds from the top-left corner around the
  bottom to the top-right corner. Removing W again shortens the path by 2.</li>
<li><i>W has two neighbors that are walls</i>: Removing W doesn't shorten the
  path at all. (The reason we have this case is that removing this wall can
  open up other walls to be removed.)</li>
</ul>
</p><p>
Here are some illustrations of the above three cases. (For simplicity, we
assume here that all the <code>?</code>s are walls, but the argument holds
regardless.)
</p>
<img src="mr_paths.png"/>
<p>To solve the problem, then, we just continually remove walls from the map
(keeping in mind that removing a wall may make another wall removable) until
the shortest path is equal to <b>D</b>. For the Small, we can repeatedly scan
the map for removable walls and remove a wall; we continue this until the
shortest path is the required length.
</p><p>
For the Large dataset, scanning the map repeatedly is too slow, so we need a
different approach. We can figure out a list of walls to remove,
in order, then binary search on the number of walls to remove to make a path of
the required length. To find this list, we can scan the map once, then
initialize a queue containing all the removable walls. Then, each time we
choose a wall to remove next, we scan each of its neighbors to see if it's
removable, and add any newly-removable walls to the back of the queue. We also
need to scan the neighbors for walls that may have become unremovable, and
remove any such walls from the queue. For example, if a connected component is
just a 2x2 square, all of its walls are initially removable, but after removing
one of them, only two of the three remaining walls can be removed. So we may
sometimes need to remove a wall from the queue, and then perhaps even re-insert
it later.
</p><p>
With this method, we're only scanning the entire map once, then doing constant
additional work per wall we remove (O(N) total), so it's fast enough for the
Large. (This method will eventually remove every wall, except that it might
leave an extra-thick unremovable border. This border doesn't matter, since
removing it wouldn't change the shortest path.)
</p>
<h3>A formal proof</h3>
<p>
As before, let L<sub>i</sub> be the shortest path initially and M be the
Manhattan distance. We claim that the problem is solvable for any <b>D</b> (of
the same parity as L<sub>i</sub>) between L<sub>i</sub> and M. It suffices to
show that you can always delete a wall while keeping the maze valid and without
decreasing the current shortest path length L by more than 2.
</p><p>
Consider some connected component of walls. If it includes the outer boundary,
let B be the set of walls on the outer boundary. Otherwise, let B be an
arbitrary wall in the component. Let A be a wall in the component that is
adjacent to an empty cell and maximally far apart from B (based on distance
staying within the component). We'll delete A.
</p><p>
This adds an empty cell adjacent to another one, and so all empty cells stay
connected. We next need to show that it can't make two walls touch only at a
corner. By way of contradiction, suppose that X and Y are walls adjacent to
both A and an empty cell Z. Z and A are connected by empty cells, so X and Y
cannot be connected by walls after deleting A. Thus one of X or Y must be
further from B than A is. But X and Y are not on the outer boundary, and are
connected to B before A is deleted, and are adjacent to Z, so we have a
contradiction.
</p><p>
Finally, we need to show that deleting A cannot make two empty cells greater
than two steps closer to each other. The only way this could happen is if A
were adjacent to empty opposite cells X and Y, and walls W and Z. As above,
X and Y are connected, so Z and W cannot be connected by walls after deleting
A. This leads to the same contradiction as before. W and Z may not be adjacent
to an empty cell, but they are adjacent to something other than A that is.
Either W or Z or this adjacent cell will contradict the choice of A. Note that
the key claim here is false if walls are allowed to touch only at corners, but
the problem setup disallows that.
</p>


  <div class="test-data-download-wrapper">
    <div class="test-data-download-header">
      <div class="test-data-download-header-text">Test Data</div>
      <div class="test-data-download-header-download-button">
        <a href="test_data.zip" target="_blank">
          <i class="material-icons grey">save_alt</i>
        </a>
      </div>
    </div>
    <div class="test-data-download-content">
      <div class="test-data-download-warning">
        <span class="material-icons" style="color: grey; vertical-align: middle;">info</span>
        <span style="vertical-align: middle;">We recommend that you practice debugging solutions without looking at the test data.</span>
      </div>
    </div>
  </div>



    </div>
  </body>
</html>
