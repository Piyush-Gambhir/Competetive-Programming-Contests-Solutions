
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Code Jam 2016 - Round 1B</h3><h1>Analysis: Technobabble</h1><h2>Technobabble: Analysis</h2>

<h3>Small dataset</h3>

<p>Each topic on the list could be "faked" or "un-faked." One natural brute
force solution is to enumerate all possible orderings of the topics, and pick
the one that has the most faked topics.
</p><p>
It's easy to check whether a topic could have been faked: simply check
whether the first word of the topic appears as a first word earlier in the
list, and the second word of the topic appears as a second word earlier in the
list. Note that marking a topic as faked does not change whether or not topics
later in the list can be marked as faked, so using this strategy, it is
optimal to always count a topic as faked if possible.
</p><p>
However, there are <b>N</b>! possible orderings, which is too large to
enumerate even for the small dataset where <b>N</b> &le; 16 (16! is on the
order of 21 trillion). We need a better approach. Rather than trying to
maximize the number of faked topics, let's think about the reverse problem:
trying to minimize the number of un-faked topics.
</p><p>
The key observation is that any possible set of un-faked topics must
contain every first word at least once and every second word at least once
&mdash; otherwise, there would be a faked topic that contained a word that
was not available for the faker to use. Conversely, any set containing every
first word at least once and every second word at least once could be a
possible set of un-faked topics &mdash; simply put all the topics from the un-
faked set at the top of the list. So, the question we need to answer is this:
<em>What is the smallest set of topics that contains every first word at least
once and every second word at least once?</em>
</p><p>
A brute-force approach, which works for the Small dataset, is to enumerate
all subsets of topics and pick the subset with the fewest topics that covers
every first word at least once and every second word at least once. Since
there are 2<sup><strong>N</strong></sup> subsets, this solution runs in
exponential time, which is fine for the Small dataset (2<sup>16</sup> =
65,536).
</p>
<h3>Large dataset</h3>
<p>
For the large dataset, the exponential time solution will not work. It
turns out that there is a polynomial time solution to the problem. We will
illustrate the solution using graph theory.
</p><p>
Let each word be a vertex in a
<a href="https://en.wikipedia.org/wiki/Bipartite_graph">
bipartite graph</a> in which each topic is an edge connecting two vertices.
The sample input below corresponds to the following graph (we'll explain the
colors of the edges in a moment).
</p>
<code>
HYDROCARBON COMBUSTION<br/>
BIOMASS COMBUSTION<br/>
QUAIL COMBUSTION<br/>
QUAIL BEHAVIOR<br/>
QUAIL CONTAMINATION<br/>
GROUNDWATER CONTAMINATION<br/>
GROUNDWATER HYDROLOGY<br/>
</code>
<p>
<img alt="Bipartite graph in which each node is a word and each edge is a topic." src="technobabblebipartite.png"/>
</p><p>
The problem we're trying to solve on this graph is the <em>minimum edge
cover</em>; that is, finding the smallest set of edges such that each vertex
is connected to at least one edge. This corresponds to the smallest set of
topics containing every first word at least once and every second word at
least once.
</p><p>
The minimum edge cover problem is related to finding a <em>maximum
matching</em> of a graph (the largest set of edges without any common
vertices): the two will always have the same number of connected components.
If it's not immediately obvious why this is the case, convince yourself by
drawing some graphs on paper
and trying to come up with a counter-example. We can additionally observe that
every vertex left out of a maximum matching must be connected to a vertex in
the maximum matching; otherwise, we could have added that pair to the maximum
matching. With these facts, we can use
<a href="https://en.wikipedia.org/wiki/Edge_cover#Algorithms">a two-step
algorithm</a> to compute a minimum edge cover on our bipartite graph:</p>
<ol>
<li>Find a maximum cardinality bipartite matching of the graph, which can be
done in
<a href="https://en.wikipedia.org/wiki/Matching_(graph_theory)#In_unweighted_bipartite_graphs">
polynomial time</a> using an approach such as the
<a href="https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm">
Ford-Fulkerson algorithm</a> or the
<a href="https://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm">
Hopcroft&ndash;Karp algorithm</a>. One such matching
is shown above in <span style="color:red">red</span>.</li>
<li>Iterate over the remaining edges, and greedily add edges that connect to
an unused vertex. The edges added by this step are shown above in
<span style="color:blue">blue</span>.</li>
</ol>
<p>
In fact, all we really need to know is the <em>size</em> of a minimum
edge cover: the number of edges in a maximum matching plus the number of
vertices not included in a maximum matching. The solution to the problem is
then simply the total number of edges (topics) minus the size of a minimum edge
cover.
</p>


  <div class="test-data-download-wrapper">
    <div class="test-data-download-header">
      <div class="test-data-download-header-text">Test Data</div>
      <div class="test-data-download-header-download-button">
        <a href="test_data.zip" target="_blank">
          <i class="material-icons grey">save_alt</i>
        </a>
      </div>
    </div>
    <div class="test-data-download-content">
      <div class="test-data-download-warning">
        <span class="material-icons" style="color: grey; vertical-align: middle;">info</span>
        <span style="vertical-align: middle;">We recommend that you practice debugging solutions without looking at the test data.</span>
      </div>
    </div>
  </div>



    </div>
  </body>
</html>
