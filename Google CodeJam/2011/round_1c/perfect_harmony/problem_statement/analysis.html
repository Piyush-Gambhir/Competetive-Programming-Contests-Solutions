
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Code Jam 2011 - Round 1C</h3><h1>Analysis: Perfect Harmony</h1><p>
This problem turned out to be very, very tricky, due to a number of cases to consider and the possibility of integer overflow. Thus, we will go over the solution with some care.
</p>

<p>
To solve the small data set for this problem, it is enough to iterate over all notes that can be played by Jeff, and for each of them check whether it is in harmony with all the other notes. Note that there are two cases to consider for each note - either its frequency has to divide the frequency of Jeff's note, or it has to be divisible by it.
</p>

<p>
For the large data set, this strategy will not be sufficient - there are too many notes that Jeff can play to check.
</p>

<p>
We will begin by sorting all the input frequencies. Now assume that the frequency of the note that Jeff will play (let us denote it by <b>F</b>) is somewhere between frequencies <b>f<sub>k</sub></b> and <b>f<sub>k+1</sub></b>. This means, in particular, that all the frequencies <b>f<sub>1</sub></b>, <b>f<sub>2</sub></b>, up to <b>f<sub>k</sub></b> are no larger than <b>F</b>; so <b>F</b> has to be divisible by all of them. This means that <b>F</b> has to be divisible by their Least Common Multiple (which we will denote LCM(<b>f<sub>1</sub></b>, <b>f<sub>2</sub></b>, ..., <b>f<sub>k</sub></b>)). Similarly, <b>F</b> has to divide the Greatest Common Divisor of <b>f<sub>k+1</sub></b> up to <b>f<sub>N</sub></b>.
</p>

<h3> Calculating the GCDs and LCMs </h3>

<p>
To make any use of this information, we need to calculate all the LCMs of sets <b>f<sub>1</sub></b>, ..., <b>f<sub>k</sub></b> up to any <b>k</b>, and also the GCDs of sets <b>f<sub>k+1</sub></b>, ..., <b>f<sub>N</sub></b> for any k. 
</p>

<p>
Let us recall that the GCD of two numbers <b>a</b> and <b>b</b> can be calculated using the <a href="http://en.wikipedia.org/wiki/Euclidean_algorithm" target="_blank">Euclidean algorithm</a> in O(log(<b>a + b</b>)) time. To calculate the LCM of two numbers, we use the formula LCM(<b>a</b>, <b>b</b>) = <b>a</b> * <b>b</b> / GCD(<b>a</b>, <b>b</b>). Using this, we can calculate all the needed GCDs and LCMs in O(<b>N</b>) GCD operations, inductively. For instance, having already calculated the first <b>k-1</b> LCMs, we calculate the <b>k</b>th as follows: LCM(<b>f<sub>1</sub></b>, ..., <b>f<sub>k</sub></b>) = LCM(LCM(<b>f<sub>1</sub></b>, ..., <b>f<sub>k-1</sub></b>), <b>f<sub>k</sub></b>), and the first of those numbers is already calculated.
</p>

<p>
Note that one can also calculate all the GCDs and LCMs directly, in O(<b>N</b><sup>2</sup>) GCD operations. With the limit of 10<sup>4</sup> on GCD this should also run in time.
</p>

<p>
One final comment to make here is that when calculating the LCMs, we should be careful to avoid overflow. It may turn out that the LCM of some of the input frequencies does not fit into a 64-bit integer (in general, the LCM of 10<sup>4</sup> numbers, each up to 16 digits, can have even 160,000 digits!). However, note that Jeff cannot play notes with frequency greater than 10<sup>16</sup>, thus if the LCM of any numbers turns out to be greater than 10<sup>16</sup> (or even greater than <b>H</b>) we can safely replace it by 10<sup>16</sup> + 1 without changing the answer - Jeff will not be able to play a note with a frequency divisible by this LCM anyway. Thus, when we calculate the formula <b>a</b> * <b>b</b> / GCD(<b>a</b>, <b>b</b>) we should first divide any of the two numbers, say <b>a</b>, by the GCD, then check whether the resulting product exceeds <b>H</b> (e.g. by checking whether (<b>H</b> + 1) / <b>b</b> &ge; <b>a</b> / GCD(<b>a</b>, <b>b</b>), and perform the multiplication only if it does not.
</p>

<h3> Special cases first </h3>
<p>
Before going on, we should also consider that there are two special cases when the analysis above does not apply - when <b>F</b> divides all the input frequencies, and when <b>F</b> is divisible by all of them.
</p>

<p>
There are a number of ways to take care of them. For the first, the easiest is to add another note with frequency 1 to the input. This will not make Jeff's task harder, as any number is divisible by 1, and on the other hand will assure that <b>F</b> is always divisible by at least one of the numbers in the input.
</p>

<p>
For the upper bound, no analogous trick exists (there is no number that is divisible by any <b>F</b> Jeff might choose; one might consider the LCM of all the numbers that Jeff's instrument can play, but this is usually too large. Thus, if we fail to find a solution <b>F</b> lying between any two of the input frequencies, we have to consider this case separately. Fortunately, it is not complicated - if <b>C</b> is the LCM of all the input numbers, then the result will be the smallest multiple of <b>C</b> that is greater or equal <b>L</b>, provided it is no larger than <b>H</b>.
</p>

<h3> The standard cases </h3>
<p>
Notice that as we are looking for the lowest frequency Jeff can play, we can investigate the possibilities one by one - first check if there is a solution between <b>f<sub>1</sub></b> and <b>f<sub>2</sub></b>, if yes - return it (recall that <b>f<sub>1</sub></b> is 1, so there is no solution smaller than <b>f<sub>1</sub></b>). If no solution was found, look between <b>f<sub>2</sub></b> and <b>f<sub>3</sub></b>, and so on. Finally, if no solution is found between <b>f<sub>N-1</sub></b> and <b>f<sub>N</sub></b>, we consider the special case analyzed above.
</p>

<p>
Now for the crux of the problem - how can we check (quickly) whether a solution is to be found between <b>f<sub>k</sub></b> and <b>f<sub>k+1</sub></b>? Note that this interval can possibly contain up to 10<sup>16</sup> numbers, so a brute force check is unsatisfactory.
</p>

<p>
Recall that if <b>F</b> is between <b>f<sub>k</sub></b> and <b>f<sub>k+1</sub></b>, then it has to divide GCD(<b>f<sub>k+1</sub></b>, ..., <b>f<sub>N</sub></b>) (we will denote this number by <b>D</b>), and it has to be divisible by LCM(<b>f<sub>1</sub></b>, ..., <b>f<sub>k</sub></b>) (we will denote this number by <b>C</b>). Thus, in particular, if <b>C</b> does not divide <b>D</b>, we know there is no solution in this interval.
</p>

<p>
There are two more easy cases to consider. If the intervals [<b>L</b>, <b>H</b>] and [<b>C</b>, <b>D</b>] are disjoint, there is obviously no solution in this interval. If <b>C</b> lies in the interval [<b>L</b>, <b>H</b>] (and divides <b>D</b>, which we already checked), it is obviously the smallest solution in this interval, so we may safely return it.
</p>

<p>
Notice that there is at most one interval for which those easy (and in particular, constant time) checks will not suffice. Indeed, if for some <b>k</b> the intervals [<b>L</b>, <b>H</b>] and [<b>C</b>, <b>D</b>] are not disjoint, then for any subsequent interval [<b>C'</b>, <b>D'</b>] obtained for a different <b>k'</b> either <b>C'</b> lies in [<b>L</b>, <b>H</b>], or the two intervals are disjoint, as <b>L</b> &le; <b>D</b> &le; <b>f<sub>k+1</sub></b> &le; <b>C'</b>.
</p>

<p>
Finally, we can concentrate on this one interval. We want to find the smallest number <b>F</b> in the interval [<b>L</b>, <b>H</b>] that divides <b>D</b> and is divisible by <b>C</b>. For this, it is enough to consider all the divisors of <b>D</b> and check them one-by-one. The divisors of <b>D</b> can be enumerated in time proportional to the square root of <b>D</b> - for each divisor <b>d</b>, either <b>d</b> or <b>D</b>/<b>d</b> is no larger than the square root of <b>D</b>, thus to find all the divisors we check all the numbers no larger than the square root, and if a number <b>d</b> divides <b>D</b>, we add both <b>d</b> and <b>D</b>/<b>d</b> to the list of divisors. This algorithm returns the divisors almost sorted, so it is easy to consider them in ascending order and find the first that both is divisible by <b>C</b> and falls into the interval [<b>L</b>, <b>H</b>].
</p>

<h3> Summary </h3>
<p>
This was not an easy problem, and required quite a lot of care and attention. Let us enumerate the steps, to wrap it up:
</p>
<ul>
<li> Sort all the input frequencies (in O(<b>N</b> log <b>N</b>) time) </li>
<li> Add 1 to the beginning of the list of inputs (in O(1) time :) ) </li>
<li> Calculate the prefix LCMs and suffix GCDs (in O(<b>N</b>) GCD operations, each taking O(log <b>H</b>) time (as we do not consider results greater than <b>H</b>) </li>
<li> For each <b>k</b> from 1 to <b>N</b>-1 check whether the appropriate LCM divides the appropriate GCD (if no, proceed to next interval); if the LCM falls into [<b>L</b>, <b>H</b>] (if yes, return the LCM) and whether the intervals [LCM, GCD] and [<b>L</b>, <b>H</b>] intersect (if no, proceed to the next interval). This takes constant time for each interval, so O(<b>N</b>) time in total. </li>
<li> If we are still analyzing this interval, find all the divisors of the GCD and check them one by one. This takes O(sqrt(<b>H</b>)) time. </li>
<li> If no answer was found as yet, it remains to check the smallest multiple of the LCM of all the inputs that is greater or equal than <b>L</b>. This is done in constant time.</li>
</ul>

<p>
There are other approaches possible to this problem, too. For instance, one may analyze all the divisors of the largest input frequency, and for each of them use binary search to find the interval that contains it and (in constant time, using precalculated LCMs and GCDs) check whether it is a correct solution. We encourage you to analyze the details of this approach yourself.
</p>


  <div class="test-data-download-wrapper">
    <div class="test-data-download-header">
      <div class="test-data-download-header-text">Test Data</div>
      <div class="test-data-download-header-download-button">
        <a href="test_data.zip" target="_blank">
          <i class="material-icons grey">save_alt</i>
        </a>
      </div>
    </div>
    <div class="test-data-download-content">
      <div class="test-data-download-warning">
        <span class="material-icons" style="color: grey; vertical-align: middle;">info</span>
        <span style="vertical-align: middle;">We recommend that you practice debugging solutions without looking at the test data.</span>
      </div>
    </div>
  </div>



    </div>
  </body>
</html>
