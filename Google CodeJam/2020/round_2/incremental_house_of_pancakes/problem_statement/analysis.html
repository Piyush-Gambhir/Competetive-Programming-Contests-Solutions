
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Code Jam 2020 - Round 2</h3><h1>Analysis: Incremental House of Pancakes</h1><h3>Test Set 1</h3>
<p>
  Test Set 1 is small enough that we can simulate the process. Since each step
  removes at least one pancake from a stack, this takes at most
  <b>L</b> + <b>R</b> operations. One thing we can notice is that because the
  i-th step removes i pancakes, the first i steps together remove
  i &times; (i + 1) / 2 pancakes. This means that the number of steps is
  actually bounded by 2 &times; sqrt(<b>L</b> + <b>R</b>), which means the
  simulation algorithm is also O(sqrt(<b>L</b> + <b>R</b>)). It would work for
  limits that are much larger than the ones in this test set!
</p>
<h3>Test Set 2</h3>
<p>
  Unfortunately, O(sqrt(<b>L</b> + <b>R</b>)) is still too slow for the
  10<sup>18</sup> limits in Test Set 2, especially with 1000 cases to go
  through!
</p><p>
  We can simulate multiple steps at a time by noticing that there are two
  distinct phases of the process. The first phase uses a single stack: the one
  that starts out with more pancakes. The second phase begins when that stack
  has a number of pancakes remaining that is less than or equal to the number
  in the other stack. Notice that if the left stack is the one we serve from in
  phase 1, it is possible that it is also the first one to be used in phase 2.
  It is also possible that no customer is served in either phase.
</p><p>
  We may serve a lot of customers in phase 1 depending on the difference in
  size between the stacks at the beginning. If we serve i pancakes from one
  stack, we remove i &times; (i + 1) / 2 pancakes from it, so we can
  efficiently calculate how many customers we can serve in phase 1 by finding
  the largest i<sub>1</sub> such that
  i<sub>1</sub> &times; (i<sub>1</sub> + 1) / 2 is less than or equal to the
  difference in number of pancakes between the two stacks at opening time. We
  can calculate that either by solving a quadratic equation and rounding
  carefully, or by using
  <a href="https://en.wikipedia.org/wiki/Bisection_method">binary search</a>.
</p><p>
  The second phase is where the magic happens. Let us say that when serving
  customer i, stack X is used and Y is not, but then we serve customer i + 1
  from stack Y. Therefore, stack X lost i pancakes and stack Y lost i + 1
  pancakes. Since X was used instead of Y for customer i, X must have had no
  fewer pancakes than Y had at that time. Since X lost fewer pancakes than Y, X
  must have had more pancakes than Y after we served customers i and i + 1.
  This means if we ever use two different stacks in the order (X, Y), we must
  use X next. And, using the same reasoning with the roles reversed, we have
  now have used (Y, X) most recently, so we will use Y next, and so on. So,
  once we have used both piles, we always go on alternating between them.
</p><p>
  We can use this observation to efficiently determine what happens in phase 2.
  After updating the original totals by subtracting the pancakes served in
  phase 1, we know which stack is used first in phase 2. The first stack will
  be used to serve customers i<sub>1</sub> + 1, i<sub>1</sub> + 3,
  i<sub>1</sub> + 5, ... which means that if it is used for c<sub>1</sub>
  customers, a total of (i<sub>1</sub> &times; c<sub>1</sub>) +
  (c<sub>1</sub>)<sup>2</sup> pancakes are served from it. At
  this point, we know the value of i<sub>1</sub>, so once again, we can
  calculate c<sub>1</sub> by solving a quadratic equation or binary search. The
  other stack is similar, since it will be used to serve customers
  i<sub>1</sub> + 2, i<sub>1</sub> + 4, i<sub>1</sub> + 6, ... so if it is used
  for c<sub>2</sub> customers, a total of ((i<sub>1</sub> + 1) &times;
  c<sub>2</sub>) + (c<sub>2</sub>)<sup>2</sup> pancakes will be
  served from it. So the final number of customers served is
  i<sub>1</sub> + c<sub>1</sub> + c<sub>2</sub>. The total numbers of pancakes
  served from each stack come from the quantities in phase 2, with the quantity
  from phase 1 added to whichever stack was first.
</p><p>
  If we use binary searches, each phase requires O(log(<b>L</b> + <b>R</b>)) time.
  If we directly solve the quadratic equations, each phase is actually constant
  time. Either is fast enough for the limits of this problem.
</p><p>
  Notice that solving quadratic equations may be harder than usual, since typically
  that involves computing some square roots. While most languages provide a way to do
  that, they do it with
  <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">
  double precision floating point</a>, which does not have enough
  precision for this problem and can lead to off-by-one errors. We should either
  compute square roots directly on integers (by binary searching for the answer, for example) or
  use the built-in function, and then check the returned value and other values in its
  vicinity to find the correct rounded result.
</p>


  <div class="test-data-download-wrapper">
    <div class="test-data-download-header">
      <div class="test-data-download-header-text">Test Data</div>
      <div class="test-data-download-header-download-button">
        <a href="test_data.zip" target="_blank">
          <i class="material-icons grey">save_alt</i>
        </a>
      </div>
    </div>
    <div class="test-data-download-content">
      <div class="test-data-download-warning">
        <span class="material-icons" style="color: grey; vertical-align: middle;">info</span>
        <span style="vertical-align: middle;">We recommend that you practice debugging solutions without looking at the test data.</span>
      </div>
    </div>
  </div>



    </div>
  </body>
</html>
