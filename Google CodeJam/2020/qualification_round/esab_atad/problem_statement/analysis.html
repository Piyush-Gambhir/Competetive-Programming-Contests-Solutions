
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Code Jam 2020 - Qualification Round</h3><h1>Analysis: ESAb ATAd</h1><h3>Test Set 1</h3>
<p>
  In Test Set 1, there are only 10 positions in the string. We can query for
  each of them and then submit the complete string, without having to worry
  about any quantum fluctuations (which would only happen if we submitted an
  11th query).
</p>
<h3>Test Set 2</h3>
<p>
  Here is one of various ways to solve the second test set. We begin by
  querying for the first ten positions in the real string, then create a
  "possibility set" containing all 1024 20-character strings that begin with
  those 10 characters. Then we update our "possibility set" to contain all
  strings that could have arisen from those strings after the next quantum
  fluctuation. The correct answer is in here somewhere &mdash; now we need to
  narrow the set down!
</p><p>
  Before making each subsequent query, we first find the string index (between
  1 and 20) at which the proportion of <code>0</code>s and <code>1</code>s
  among the strings in our possibility set is most nearly even. Then we query
  the real string at that index, and eliminate from the possibility set any
  strings that are not consistent with that information. Whenever we can
  indeed find a position with even proportions, we are guaranteed to cut the
  size of the set in half, but if there is no such position, we may not be
  able to eliminate that many possibilities. We can continue in this way,
  remembering to expand the possibility set every time there is a quantum
  fluctuation, until only one possibility remains, which must be the answer.
</p><p>
  It is not easy to prove that this strategy will converge upon an answer.
  Intuitively, we can observe that a quantum fluctuation increases the size
  of the possibility set by at most 4, and even if we somehow only cut the
  possiblity set by 20% with each pruning, we would still easily beat that
  factor-of-4 increase and make enough progress to finish within 150 queries.
  Moreover, it would not be possible for the strings in the possibility set to
  all be distinct while being so similar at <i>every</i> individual position
  (recall that we always pick the position that will be <i>most</i> useful to
  us in the worst case). Also, Test Set 2 is a Visible Verdict set, so we
  might as well just submit our answer and see.
</p>
<h3>Test Set 3</h3>
<p>
  The above strategy will not work for 100-character strings, since the
  possibility set would be astronomically huge. Fortunately, there is a much
  simpler approach.
</p><p>
  Observe that if we can find two positions that are equidistant from the
  center of the string and have the same value, we can use them to detect when
  a quantum fluctuation has included a complementation (with or without a
  reversal). Suppose, for example, that the two ends of the string are
  <code>0</code> just before a quantum fluctuation. After the fluctuation, we
  can check the first one. If it is <code>1</code>, then there was a
  complementation; if not, there wasn't one. This is true regardless of
  whether that quantum fluctuation included a reversal.
</p><p>
  Now suppose that we continue to check pairs of positions in this way, moving
  inward one step at a time. After every quantum fluctuation, we must spend
  one query to check for complementation so we can update our existing
  knowledge about the string if there has been one. If every pair turns out to
  be a "same pair" like the first pair, then we never needed to care about
  reversals anyway (since the string is palindromic), and we are done.
</p><p>
  But what if, in the course of this, we find a "different pair"? Such pairs
  are helpful in their own way! If we query the first position of a
  "different pair" after a quantum fluctuation and we find that that bit has
  changed, then we know that either a complementation or reversal has happened,
  but not both.
</p><p>
  Once we have such a "different pair", we can use it in conjunction with the
  "same pair", spending 2 out of every 10 queries to learn exactly what happened
  in each quantum fluctuation. For example, if the first position of our
  "same pair" stayed the same but the first position of our "different pair"
  did not, we know that the quantum fluctuation included a reversal but no
  complementation.
</p><p>
  In the above analysis, we assumed we would encounter a "same pair" first. If
  the first pair is different, though, we can proceed until we encounter a
  "same pair"; if we never encounter one, then we do not care about the
  distinction between complementation and reversal, because the operations are
  equivalent for that particular string. If we do encounter a "same pair",
  though, then we can proceed as above.
</p><p>
  How many queries will we need in the worst case? We can use all of our first
  10 to gather data, since whatever happened in the quantum fluctuation at the
  start of the problem is unknowable and does not matter. After that, we may
  need to use up to 2 out of every 10 queries to reorient ourselves before
  spending the remaining 8 gathering data. So, to be sure we can find the
  entire string, we will need 10 queries, plus 11 more sets of 10 queries in
  which we learn 8 positions each time, (to get us to 98 positions known),
  plus 2 more queries for a final reorientation, plus 2 more to get the last
  two positions. That is a total of 124, which is well within the allowed
  limit of 150.
</p>
<h3>Regarding the name...</h3>
<p>
  Last year, we had the
  <a href="https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/00000000000881de" target="_blank">Dat Bae problem</a>
  about deletions from a string in a database; the name was
  <code>Data Base</code>, altered in a way that reflected the theme.
  <code>ESAb ATAd</code> is similar, with case change serving as a rough
  equivalent of complementation. (Imagine how much the Code Jam team has
  enjoyed trying to type the name correctly each time!)
</p>

    </div>
  </body>
</html>
