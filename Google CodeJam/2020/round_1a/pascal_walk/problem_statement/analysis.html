
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Code Jam 2020 - Round 1A</h3><h1>Analysis: Pascal Walk</h1><h3>Test set 1</h3>
<p>
  The answer for <b>N</b> &le; 500 can always be constructed by walking along the leftmost
  positions of the rows of the triangle: (1, 1), (2, 1), ..., (<b>N</b>-1, 1), (<b>N</b>, 1).
</p><p>
  We can handle the case <b>N</b> = 501 by making a detour to pick up the 2 in the third row before
  returning to the left side. That is, our walk takes us through the positions (1, 1), (2, 2),
  (3, 3), (3, 2), (3, 1), (4, 1), ..., (498, 1).
</p>
<h3>Test set 2</h3>
<p>
  With only 1000 possible test cases to consider, we can find an answer to each one before
  submitting. One way to do this is to walk over the triangle in e.g. a breadth-first or random
  way, taking care never to reuse a position or visit more than 500 positions. We can check our
  cumulative sum at each position, and whenever we encounter a sum that we have never seen before,
  we record the sequence of positions that we used to obtain it. When our sum exceeds 1000, we
  backtrack in our search or start over with a new random path, and so on, until we have an answer
  for every possible <b>N</b>. It's difficult to prove a priori that this will work, but we can be
  optimistic given that the top few rows of the triangle have many small values to work with.
  Indeed, this method finds a full set of solutions very quickly.
</p><p>
  An alternate method is to observe that the positions immediately to the right of the leftmost
  positions &mdash; named (x, 2) for each x &ge; 2 &mdash; are 1, 2, 3, 4, 5, and so on. We can
  move from the top position in the triangle down to the 1 at position (2, 1), then follow that
  line to the 2 at (3, 2), the 3 at (4, 3), etc., until our next move would cause the cumulative
  sum to exceed our target. Then, we can instead make a move to the left to reach a 1 on the left
  edge of the triangle, and then proceed downward along that edge, taking as many extra 1s as we
  need. Since the sum of the first 45 natural numbers is over 1000, we can be sure that we will
  never need to take more than 45 of these extra 1s, or visit more than 45 of the positions along
  this line of natural numbers. This ensures we never use more than 90 positions in total.
</p>
<h3>Test set 3</h3>
<p>
  There are various ways to solve the third test set, but one of our favorites takes advantage of a
  special property of Pascal's triangle: the entries in the r-th row (counting starting from 1) sum
  to 2<sup>r-1</sup>. This is to be expected from the way in which each row is constructed from the
  previous one: each element in a row contributes to two elements in the next row, so the sum
  doubles with each row.
</p><p>
  This observation suggests a strategy for constructing any <b>N</b> that we want: write <b>N</b> in
  binary, and then look through that representation, starting from the least significant bit. If
  the r-th least significant bit (counting starting from 1) is a 1, our path should consume all of
  the elements in the r-th row. If the r-th least significant bit is a 0, we should skip that row
  somehow. We only need the first 30 rows of the triangle, since the 31st row's sum is
  2<sup>30</sup>, which is larger than the maximum possible <b>N</b> of 10<sup>9</sup>. Even if we
  used every element in these first 30 rows (which we would never need to), that would only use 465
  positions, which is within the limit of 500.
</p><p>
  This doesn't quite work as written, though, because our path must be continuous, and so there is
  no way to skip a row. But we can get close via the following variant: proceed down one side of
  the triangle (that is, the diagonal line of 1s) as long as we keep encountering 0 bits. Whenever
  we encounter a 1 bit, we send our path horizontally across the corresponding row, sending us to
  the other side of the triangle. This almost gets us the number we want, but we probably overshoot
  because we have consumed some extra 1s from the rows corresponding to 0 bits. We can be sure that
  there are fewer than 30 of those, though, since we visit at most 30 rows.
</p><p>
  So, we can use that variant, but instead of constructing <b>N</b>, we construct <b>N</b>-30
  instead. Once we finish, we can tack on additional 1s from our current edge of the triangle until
  we reach <b>N</b>. (We can handle cases with <b>N</b> &le; 30 specially, and just go down one
  edge of the triangle.)
</p><p>
  There are other less elaborate ways to solve this test set, though! One is to walk down the
  centers of the rows (e.g., going from (1, 1) to (2, 1) to (3, 2) to (4, 2) to (5, 3)...). This is
  where the largest numbers live, so we will grow our sum as rapidly as possible. At some point,
  though, when moving downward would make our sum grow too much, we can instead move to a one step
  away from the center and continue zigzagging downward, and so on. Eventually we will reach the
  edge full of 1s, and we can take as many more as we need. We must be careful not to increase the
  sum so fast that we will not be able to "escape" to the edge of 1s. Nor should we reach the edge
  too early, since we can only take so many 1s. However, it's not too difficult to get this method
  to work.
</p>


  <div class="test-data-download-wrapper">
    <div class="test-data-download-header">
      <div class="test-data-download-header-text">Test Data</div>
      <div class="test-data-download-header-download-button">
        <a href="test_data.zip" target="_blank">
          <i class="material-icons grey">save_alt</i>
        </a>
      </div>
    </div>
    <div class="test-data-download-content">
      <div class="test-data-download-warning">
        <span class="material-icons" style="color: grey; vertical-align: middle;">info</span>
        <span style="vertical-align: middle;">We recommend that you practice debugging solutions without looking at the test data.</span>
      </div>
    </div>
  </div>



    </div>
  </body>
</html>
