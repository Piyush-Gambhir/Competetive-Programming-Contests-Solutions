
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Code Jam 2012 - World Finals</h3><h1>Analysis: Xeno-archaeology</h1><p> To begin with, let's try to formalize the rules of forming the pattern of tiles. If the center is at some position <b>x</b>, <b>y</b>, then the red tiles are those in positions <b>x'</b>, <b>y'</b> for which the number max(|<b>x</b> - <b>x'</b>|, |<b>y</b> - <b>y'</b>|) is odd, while the blue tiles are those for which this number is even. This is because the formula max(|<b>x</b> - <b>x'</b>|, |<b>y</b> - <b>y'</b>|) = <b>C</b> for any <b>C</b> describes a square ring around <b>x</b>, <b>y</b>, and the rings alternate color with the parity of <b>C</b></p>

<p> For the small problem, we can prove that if there exists a solution, there exists one with |<b>X</b>| + |<b>Y</b>| &lt; 202. Thus, we can check all candidates for the center, for each one check whether all the tiles have the right colors, and output the best candidate. This will not run in time for the large data, of course, as we will have over 10<sup>30</sup> candidate centers to check.</p>

<br/>
<p><b>Single tile analysis</b></p>

<p> We may now assume we know the parity of <b>x</b> and <b>y</b>. We will simply check all four possibilities, finding the best possible choice of the center for each of the four assumptions, and then pick the one specified by the tie-breaking rules (or output "Too damaged" if none of the four assumptions led to finding a viable center for the pattern). This makes it easier to analyse the information gained by knowing the color of a single tile. Suppose the tile at some position <b>x'</b>, <b>y'</b> is, say, red. This means max(|<b>x</b> - <b>x'</b>|, |<b>y</b> - <b>y'</b>|) has to be odd. Now, we know the parities of <b>x</b>, <b>y</b>, <b>x'</b> and <b>y'</b>, and so:
<ul>
<li> if both <b>x</b> - <b>x'</b> and <b>y</b> - <b>y'</b> are odd, then any choice of a center (satisfying the parity requirements for <b>x</b> and <b>y</b>) is going to fit our knowledge; </li>
<li> if both <b>x</b> - <b>x'</b> and <b>y</b> - <b>y'</b> are even, then there is no solution satifying the parity requirements; </li>
<li> if, say, <b>x</b> - <b>x'</b> is odd, while <b>y</b> - <b>y'</b> is even, we have to have |<b>x</b> - <b>x'</b>| &ge; |<b>y</b> - <b>y'</b>|</li>
</li>
</ul>
If there is any tile of the second type, we can immediately return "Too damaged" for these parity assumptions. We can ignore of tiles of the first type, and now we are left only with tiles of the second type.</p>

<p>Note that in the third case, since the parities of <b>x - x'</b> and <b>y - y'</b> differ, it doesn't matter whether we use a strict inequality, as the equality case is eliminated from consideration by the parity assumptions. Thus, when considering regions defined by these inequalities, we can ignore problems related to "what happens on the edges of these regions", as - by the reasoning above - the edges will necessarily be eliminated from consideration by the parity assumptions.
</p>

<p> The first and second cases are easy to analyse; the trick is to find out whether a solution exists (and if yes, find the best one) satisfying the set of conditions of the type |<b>x</b> - <b>x'</b>| &ge;/&le; |<b>y</b> - <b>y'</b>| for various <b>x'</b> and <b>y'</b>. Transforming the condition |<b>x</b> - <b>x'</b>| &ge; |<b>y</b> - <b>y'</b>| we see it is equivalent to saying that one of the following has to hold:
<ul>
<li><b>x + y</b> &ge; <b>x' + y'</b> and <b>x - y</b> &ge; <b>x' - y'</b>, or</li>
<li><b>x + y</b> &le; <b>x' + y'</b> and <b>x - y</b> &le; <b>x' - y'</b>.</li>
</ul>
</p>

<br/>
<p><b>Dividing the plane</b></p>

<p>
The lines <b>x + y</b> = <b>x<sub>i</sub> + y<sub>i</sub></b> and <b>x - y</b> = <b>x<sub>i</sub> - y<sub>i</sub></b> (which are the boundaries of the constraint-satisfaction region for the input tiles) divide the plane into at most (<b>N</b> + 1)<sup>2</sup> rectangles. The idea of our algorithm will be as follows:
<ul>
<li>Iterate over the four sets of parity assumptions about the center</li>
<li>Iterate over all rectangles formed by the boundary lines, and for each of them check whether it satisfies the constraints posed by all input tiles</li>
<li> for each rectangle satisfying the constraints, find the best (according to the tie-resolution conditions) center candidate within it (if any) </li>
<li> output the best of all center candidates found. </li>
</ul>
A fun fact is that there will be at most <b>N</b>+1 rectangles that satisfy the constraints; so we need not worry overly about the performance of the "find the optimal within the rectangle" phase (as long as it is independent of the size of the rectangle). The naive approach to the second phase is O(<b>N</b><sup>3</sup>) (for each rectangle check all tiles), which with <b>N</b> up to a thousand and 50 testcases risks being too slow, so we'll need to speed it up a bit.</p>

<p> There are many ways to trim down the runtime of the constraint-checking phase for rectangles. One sample way is to process the rectangles "row-by-row", as follows: Take the set of rectangles with <b>A</b> &le; <b>x+y</b> &le; <b>B</b>, with <b>A</b> and <b>B</b> being some two adjacent boundary values. For each input tile (out of those that set any constraints on the center position), we have two areas of constraint satisfaction; but only one of them is compatible with <b>A</b> &le; <b>x+y</b> &le; <b>B</b>, because one of the areas satisfies the constraint <b>x+y</b> &ge; <b>C</b>, while the other has <b>x+y</b> &le; <b>C</b>. This means that we know which area is the interesting one for this row; so we obtain a constraint on <b>x - y</b> that has to be satisfied by all the rectangles in this row. This will be either of the form <b>x - y</b> &le; <b>D</b>, or <b>x - y</b> &ge; <b>D</b>. We take the largest of the lower bounds, the largest of the upper bounds, and obtain a rectangle that we have to check. This algorithm runs in O(<b>N</b><sup>2</sup>) time, which will be easily fast enough.</p>

<p> A more advanced algorithm (using the sweep line technique) can be used to obtain a runtime of O(<b>N</b> log<b>N</b>) runtime. We will not describe it (as it is not necessary to obtain a fast enough program with the constraints given), but we encourage the reader to figure it out.</p>

<br/>
<p><b>Finding the best point within a rectangle</b></p>

<p>
This was the part of the problem that seemed to cause most difficulties for our contestants. There are two cases to consider here. Let's assume our rectangle is defined by <b>A</b> &le; <b>x+y</b> &le; <b>B</b> and <b>C</b> &le; <b>x-y</b> &le; <b>D</b>. 
</p>

<p>
Let us define <br/>
g(k, l) = min(|k|, |l|) if k and l are of the same sign, 0 otherwise.<br/>
If g(<b>A</b>, <b>B</b>) = 0 and g(<b>C</b>, <b>D</b>) = 0, then the point (0, 0) is within our rectangle. In this case it suffices to check the near vicinity of the origin. Specifically:
<ul>
<li> If both <b>x</b> and <b>y</b> are supposed to be even, (0, 0) is obviously the optimal solution. </li>
<li> If both <b>x</b> and <b>y</b> are supposed to be odd, then the best four points, in order, are (1, 1), (1, -1), (-1, 1) and (-1, -1). If <b>B</b> &ge; 2 we can take (1, 1) and we're done. Otherwise, if <b>D</b> &ge; 2, we take (1, -1); and so on. If all the four points are infeasible, the rectangle contains no points satisfying the parity constraints. </li>
<li> If , say, <b>x</b> is supposed to be odd, while <b>y</b> is even, the first eight candidates are (1, 0), (-1, 0), (3, 0), (1, 2), (1, -2), (-1, 2), (-1, -2), (-3, 0). Again, one can check that if none of them is feasible, the rectangle contains no points satisfying the parity constraints. The same happens when <b>x</b> is even and <b>y</b> is odd.</li>
</ul>
Thus, if (0, 0) is within the rectangle, we can check a constant number of points and take the best feasible one of them.
</p>

<p>
When (0, 0) is not within the rectangle, we first look for the smallest Manhattan distance of any point within the rectangle. It is equal to <b>M</b> := max(g(<b>A</b>, <b>B</b>), g(<b>C</b>, <b>D</b>)). As all the boundaries have parities disagreeing with the parity assumptions, the smallest Manhattan distance we can hope for is <b>M</b> + 1.
We now have an interval of points with Manhattan distance <b>M</b> + 1 in our rectangle, the best one of them is the one with the highest <b>X</b> coordinate (out of the ones fulfilling the parity conditions). The one last special case to deal with here is when the interval contains only one point, and it has the wrong parities - in this case we need to look at distance <b>M</b> + 3 (the fact that one never needs to look at <b>M</b> + 5 is left as an exercise).
</p>

<p>
It was also possible to solve this problem in a number of other ways. A pretty standard one was to identify a number of "suspicious points" within a rectangle (the vicinity of (0, 0), the vicinity of the corners, and the vicinity of places where the coordinate axes intersect the edges of the rectangle) and check them all, taking the best solution.
</p>

  <div class="test-data-download-wrapper">
    <div class="test-data-download-header">
      <div class="test-data-download-header-text">Test Data</div>
      <div class="test-data-download-header-download-button">
        <a href="test_data.zip" target="_blank">
          <i class="material-icons grey">save_alt</i>
        </a>
      </div>
    </div>
    <div class="test-data-download-content">
      <div class="test-data-download-warning">
        <span class="material-icons" style="color: grey; vertical-align: middle;">info</span>
        <span style="vertical-align: middle;">We recommend that you practice debugging solutions without looking at the test data.</span>
      </div>
    </div>
  </div>



    </div>
  </body>
</html>
