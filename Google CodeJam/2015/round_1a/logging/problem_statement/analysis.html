
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Code Jam 2015 - Round 1A</h3><h1>Analysis: Logging</h1><p>
If there is only one tree in the forest, then obviously there is no need to cut anything down, and the answer for that tree is zero.
</p>

<p>
Otherwise, let's assume we have cut down some trees so that a given point P is on the boundary.  If we follow the boundary clockwise from P, we will reach another boundary point Q.  Imagine we are standing at P and looking along the boundary line towards Q.  There can be no trees still standing to the left of this line, otherwise this would not be the boundary.
</p>

<p>
This suggests an algorithm for determining the minimum number of trees to cut down &mdash; for each point P, try each other point as a candidate for the next point around the boundary, Q; then check how many points lie on the left of the line PQ.  The size of the smallest of those sets of points is the best answer:
</p>

<pre>
For each point P
  Let M = N-1
  For each point Q &ne; P
    Let Temp = 0
    For each point R &ne; P, Q
      If R is to the left of the line PQ
        Temp = Temp + 1
    If Temp &lt; M
      M = Temp
  Output M
</pre>

<p>
Cutting down all the trees to the left of PQ for some Q is sufficient to produce a valid solution, because no matter where the remaining trees are, P will be on the boundary.  We can also be sure that this method will find the minimal solution, since whatever the minimal solution is, it will have some point Q which is the next along the boundary, and we have cut down the minimal number of trees to make that so.
</p>
	
<img src="cv_hull.png"><br>
<b>Figure 1</b>

<p>
Consider the case in figure 1.  Point #4 is already on the boundary, with Q equal to point #2, and we can see that there are no points to the left of the line PQ that we need to cut down, so the answer for point #4 is 0.
</p>


<img src="cv_cut.png"><br>
<b>Figure 2</b>

<p>
However, if P is point #5, then P is not already on the boundary.  When we choose Q to be point #3, as in Figure 2, we find that there are two points to the left of the line PQ: point #2 and point #4.  Cutting down those two trees will put P on the boundary.
</p>

<p>
However, this is not the minimal solution &mdash; when we try point #2 for Q, we will find a better solution, since only point #4 will need to be cut down.
</p>

<p>
This algorithm takes time O(N^3).  But we can do better than this.
</p>


<img src="cv_window1.png"><br>
<b>Figure 3</b>

<p>
For each new point P, build an array S containing all the other points.  Sort S by the angle of the line from P to that point.  Now, we can try each possible point Q &ne; P by iterating through S, which gives an ordering of the points which moves counter-clockwise around P.
</p>

<p>
The advantage of this method is that for any choice of Q, all the points which lie to the left of the line PQ will occur after Q in the list S.  So we can represent our current choice of Q and the set of points which lie to the left of PQ together as a "window" of points, implemented as two pointers into S &mdash; a "tail" pointer which points to <b>Q</b>, and a "head" pointer which points to the last point after <b>Q</b> which lies to the left of PQ.  We call this point <b>R</b> in the diagrams.
</p>

<p>
In figure 3, we can see the state of this window for P = #1, Q = #2, R = #6.  The tail of the window (in red) is at point #2, and the head of the window (in blue) is at point #6.  The points #3, #4, #5, #6 are the ones which are to the left of PQ, so this choice of Q gives us a candidate solution which requires 4 trees to be cut down.
</p>


<img src="cv_window2.png"><br>
<b>Figure 4</b>


<p>
To update the position of the window for the next choice of Q, we need to do two things &mdash; move the tail ahead one point to the new choice of Q, and scan forward from the current position of the head pointer to find the new choice for R.  In Figure 4, we can see that the tail has moved to point #3, and the head has moved to point #8.  We now have a candidate solution which requires cutting down 5 trees (#4, #5, #6, #7, #8).
</p>

<p>
Since the tail of the window iterates through each point once, and the head of the window iterates through each point at most twice, this part of the algorithm takes <b>O(N)</b> time for each choice of <b>P</b>.
</p>

<p>
Sorting the points takes <b>O(N&nbsp;log&nbsp;N)</b> time for each choice of <b>P</b>, so in total this solution takes <b>O(N^2&nbsp;log&nbsp;N)</b> time.
</p>

<p>
There are a few things to be careful of when implementing this algorithm:
<ul>
<li>The head of the window will reach the end of S before the tail does.  The head pointer then needs to wrap around to the start of S again, to include all the points to the left of PQ.  For example, when Q = #6, the head of the window is #11.  Then when Q advances to #7, the head of the window needs to wrap around to #2, which is at the start of the list, because point #2 is to the left of the line PQ.</li>
<li>There may be no points to the left of PQ at all; for example, if P=#4, and Q=#2.  A simple way to deal with this case is to have the head of the window equal to the tail.  The calculation of the number of trees to cut down should naturally give zero.  Then, when we advance the tail of the window by one point, also advance the head if it was at the same point.</li>
<li>There may be more than one point at the same angle from P.  This case is handled automatically.  The points that are at the same angle will occur consecutively in S.  When we choose the last such point as Q, we will correctly calculate the number of trees that need to be cut down.  For the other points at the same angle, we will mistakenly think that extra trees need to be cut down, but we will still find the minimum, so we needn't write extra code to handle this case.</li>
<li>When updating the position of the head of the window, we need to stop when the next point will be at an angle &pi; or more greater than the angle of Q.  Floating point numbers are imprecise, so we need to use an <a href="https://www.google.com/search?q=floating+point+comparison+epsilon" target="_blank">epsilon</a> when doing comparisons in these calculations.  The largest difference in angle between two points is approximately 1.25 * 10<sup>-13</sup> radians.  64-bit floating point values have easily enough precision to represent angles with this difference, so using these with an epsilon of 10<sup>-13</sup> will work.</li>
</ul>
</p>

<p>
Burunduk1, who won round 1A and had the fastest time for this problem, used an implementation of this algorithm.
</p>


  <div class="test-data-download-wrapper">
    <div class="test-data-download-header">
      <div class="test-data-download-header-text">Test Data</div>
      <div class="test-data-download-header-download-button">
        <a href="test_data.zip" target="_blank">
          <i class="material-icons grey">save_alt</i>
        </a>
      </div>
    </div>
    <div class="test-data-download-content">
      <div class="test-data-download-warning">
        <span class="material-icons" style="color: grey; vertical-align: middle;">info</span>
        <span style="vertical-align: middle;">We recommend that you practice debugging solutions without looking at the test data.</span>
      </div>
    </div>
  </div>



    </div>
  </body>
</html>
