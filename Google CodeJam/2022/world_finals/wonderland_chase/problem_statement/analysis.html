
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Code Jam 2022 - World Finals</h3><h1>Analysis: Wonderland Chase</h1><h3>Test Set 1</h3>
<p>
  The labyrinths of Wonderland can be viewed as a undirected graph. If Alice can get to a cycle
  before the Queen can reach her, then Alice will be safe. This is because Alice can always pick
  a direction of travel away from the Queen around the cycle. Conversely, if Alice cannot get to
  a cycle before the Queen, then the Queen will catch her after at most $$$2 \times \mathbf{J}$$$ moves.
  Every second move, Alice
  may move to a node, so after $$$2 \times \mathbf{J}$$$ moves Alice must have entered a cycle because
  otherwise the Queen would have caught Alice.
</p>

<p>
  Using these observations, we can formulate a dynamic programming solution. Define a recursive
  function <code>solution(alice, queen, total_moves)</code> that is true if the Queen can catch
  Alice in at most <code>total_moves</code> with both moving optimally and false otherwise.
  The solution to the problem is the minimum value for <code>total_moves</code> such that
  <code>solution($$$\mathbf{A}$$$, $$$\mathbf{Q}$$$, total_moves)</code> is true. If it is never true, then Alice is safe. 
</p>

<p>
  We can compute <code>solution(alice, queen, total_moves)</code> using a recurrence relation in 
  which we try all moves for the Queen and all moves for Alice in two nested loops calling
  <code>solution</code> recursively. The Queen is always trying to make the answer true, and
  Alice is always tryng to make it false.
</p>

<p>
  An upper bound on the complexity of our solution is $$$O(\mathbf{J}^5)$$$, since there are $$$O(\mathbf{J}^3)$$$
  states and computing a state requires at most $$$O(\mathbf{J}^2)$$$ time. A better complexity analysis
  is possible, but we already know this will be fast enough to pass Test Set 1.
</p>

<h3>Test Set 2</h3>
<p>
  A faster solution is needed for Test Set 2. We will need some more observations. Call a node
  <i>good</i> when, if Alice reaches it before being caught, Alice will always be safe. That is,
  if Alice reaches a good node, then regardless of where the Queen is, Alice can always move in a
  way that is safe. Let's consider an algorithm for finding all good nodes.
</p>
<p>
  Assuming a connected graph, leaves (nodes with degree 1) are never good because Alice can become
  cornered in them.
  We can start by deleting them. In fact, if we iteratively remove leaves until there are none left,
  then all the remaining nodes must be good, since Alice can never be cornered. This algorithm
  can be implemented in linear time using a queue of leaves and keeping track of the degree
  of each node throughout deletions.
</p>
<p>
  Define $$$\mathbf{DA}_u$$$ as the shortest path from Alice's starting node to a node $$$u$$$. Likewise,
  define $$$\mathbf{DQ}_u$$$ as the shortest path from the Queen. For a node $$$j$$$,
  if $$$\mathbf{DA}_j < \mathbf{DQ}_j$$$, then Alice can safely reach that node before being caught. We can prove
  this using a contradiction: if the Queen was able to intercept Alice anywhere on her path, then
  the Queen must have reached some node on Alice's shortest path before Alice, which would imply
  that the Queen can reach $$$u$$$ first. Note that $$$\mathbf{DA}$$$ and $$$\mathbf{DQ}$$$ can be computed
  by running one <a href="https://en.wikipedia.org/wiki/Breadth-first_search">Breadth-First Search</a>
  (BFS) each and storing the resulting table of distances.
</p>
<p>
  We can use our observations to solve the problem by considering a few cases.
  Alice will be safe if:
    <ul>
      <li>The graph is disconnected, meaning Alice and the queen start in two disconnected
        components. This can be checked by looking at either $$$\mathbf{DA}$$$ or $$$\mathbf{DQ}$$$.</li>
        <img src="img/disconnected_graph.png" alt=""/>
      <li>Alice can enter a good node $$$j$$$ such that $$$\mathbf{DA}_j < \mathbf{DQ}_j$$$.</li>
        <img src="img/loop_graph.png" alt=""/>
    </ul>
</p>
<p>
  Otherwise, Alice will get caught. Since Alice's strategy is to maximize
  the number of moves until she is caught, she will pick the junction that has the maximum 
  distance from the Queen with the condition that she can get to it first ($$$\mathbf{DA}_j < \mathbf{DQ}_j$$$). 
</p>
<img src="img/normal_graph.png" alt=""/>
<p>
  Since the solution requires only three linear passes over the graph (one to find good nodes, and
  two BFS runs), the total complexity is $$$O(\mathbf{J} + \mathbf{C})$$$.
</p>


  <div class="test-data-download-wrapper">
    <div class="test-data-download-header">
      <div class="test-data-download-header-text">Test Data</div>
      <div class="test-data-download-header-download-button">
        <a href="test_data.zip" target="_blank">
          <i class="material-icons grey">save_alt</i>
        </a>
      </div>
    </div>
    <div class="test-data-download-content">
      <div class="test-data-download-warning">
        <span class="material-icons" style="color: grey; vertical-align: middle;">info</span>
        <span style="vertical-align: middle;">We recommend that you practice debugging solutions without looking at the test data.</span>
      </div>
    </div>
  </div>


    </div>
  </body>
</html>
