
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Code Jam 2017 - Round 2</h3><h1>Analysis: Shoot the Turrets</h1><h2>Shoot the Turrets: Analysis</h2>
<h3>Small dataset</h3>
<p>
The first thing to notice is that, if a given soldier s is not the first to perform her task,
there is no reason for s to move at all until all soldiers that are to shoot a turret before s
have finished.
</p><p>
Let us call the output a strategy: a pairing between some soldiers and all turrets, in a specific
order. Given a fixed strategy, we can check if it's viable with one
<a href="https://en.wikipedia.org/wiki/Breadth-first_search">BFS</a> per soldier, in order.
We stop with the first soldier that can't reach its assigned turret, if any, and report the
number shot so far. Any strategy that shoots a maximum number of turrets can be extended to
a pairing of all soldiers to turrets, so this covers all possibilities. Besides the usual
empty spaces and walls, we need to consider some empty spaces enterable but not exitable: the
spaces that are in the line of sight of turrets that are to be destroyed by a soldier after the
current one. Each check takes time linear in the size of the map, so O(<b>R</b><b>C</b>) per
soldier.
</p><p>
Unfortunately, there can be too many strategies to bruteforce them. There can be up to 10! possible
pairings and 10! orderings, which means 10!<sup>2</sup> strategies, which is way too big, so we
need to do better. We will use precomputing to optimize the check and dynamic programming
to optimize the strategy generation.
</p><p>
Let S be the number of soldiers and T the number of turrets.
To make the check faster, we can compute, for each soldier and each possible
subset of still-alive turrets, the set of reachable turrets to shoot. That requires at most
2<sup>T</sup> &times; S BFSes like the ones mentioned above, for a total complexity of
O(2<sup>T</sup> &times; S<b>R</b><b>C</b>), which is fine for the Small limits.
</p><p>
Now on to the dynamic programming: consider the function f(s, t)
which finds a strategy that shoots a maximum number of turrets for a given set of remaining
soldiers s and a given set of remaining turrets t, or decides that there isn't one. Each of
s and t can be represented with a binary string of up to S and T digits, respectively.
The domain of the function, then, is of size up to 2<sup>S+T</sup>. To compute the
function, we can check every soldier against every reachable turret. Since that list is precomputed,
this takes at most S iterations over lists of length up to T. The overall computation of f, if
memoized, has a complexity of O(2<sup>S+T</sup> &times; ST), which again, finishes comfortably in
time under the Small limts.
</p>

<h3>Large dataset</h3>

<p>
For the Large dataset, anything with exponential complexity seems doomed to fail, so we need to
go a different route. We will reuse the the BFS idea (to check out whether turrets are reachable)
from the Small, but there are a lot of additional insights.
</p><p>
Let us build a <a href="https://en.wikipedia.org/wiki/Bipartite_graph">bipartite graph</a>
G with a node for each soldier and turret. G has an edge from
soldier s to turret t if and only if soldier s can destroy turret t after all other turrets have
been destroyed. A single BFS starting from each soldier can build this graph.
We state the following: destroying R turrets is possible if and only if there is a
<a href="https://en.wikipedia.org/wiki/Matching_(graph_theory)">matching</a>
in G that covers R turrets. The only if part is trivial, as the conditions for edges in the
graph are a relaxation of the conditions for the pairing we need to construct as solution.
We concentrate on proving the if part. Moreover, we provide here a computably constructive
proof, for which there is an efficient enough algorithm, meaning the proof is also an algorithm
that solves the problem.
</p><p>
First, if G is empty, the problem is solvable trivially by vacuity. For non-empty G,
we can use the
<a href="https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm">Ford-Fulkerson</a>
algorithm to find an initial maximum matching M of G of size R. We will further consider only
the soldiers present in M and ignore the others. From now on, we refer only to
soldiers matched by M, and we remove the unmatched soldier nodes from G.
Let us define the graph G' with the same nodes as G, but an edge between soldier s and turret t
only exists in G' if s can destroy t with the other turrets active. Clearly, G' is a subgraph of G.
The <a href="https://en.wikipedia.org/wiki/Directed_graph#Indegree_and_outdegree">outdegree</a> of
each soldier node in M is at least 1. If an edge (s, t) in G does not exist
in G', it is because some other turret t' is reachable by s and blocking the path to t. But then,
(s, t') is in G'. Therefore, the outdegree of each soldier not in G' is at least 1.
</p><p>
Consider the graph H that is the union of G' plus the edges in M reversed.
If H contains an edge (s, t') where t' is a turret node not covered by M, let M' be equal to M, but
replacing (s, t) by (s, t'), where (s, t) was the edge covering s present in M. Of course, M' is
a maximum matching of G of the same size as M.
If there is no such edge in H, do the following: since H is a supergraph
of G', the outdegree of each soldier node in H is at least 1. The inclusion of the
reversed edges of M in H means the outdegree of all turret nodes matched in M in H is at least 1.
Therefore, starting at any soldier and moving through edges in H, we will always encounter nodes
with outdegree 1 of soldiers and turrets covered by M, and eventually find a cycle of them.
Let us call this cycle C. Notice that the edges going out of turrets in H are only the
reversed edges from M, so C is necesarily an alternation of reversed edges from M and edges
from G'. Consider a new matching M' of G consisting of the edges of M whose reverse is not in C,
plus the edges in C whose reverse is not in M. That is, M' is M but exchanging the edges present
in C in some direction. M' in this case is also a matching of G of the same size as M. If the cycle
is of length 2, then M' ends up being exactly the same as M.
</p><p>
In both cases, we constructed a new matching M' of the same size as M with the additional property
that at least one edge of M' is present in G'. Therefore, there are some
edges in the matching that represent a number A &gt; 1 of actions that we can take now.
So, we can just take those A actions, remove all A used soldier nodes and A destroyed turret nodes,
and we are left with a smaller graph which also has a maximum matching of size R - A
(whatever is left of M'). Rinse and repeat until the graph is empty.
</p><p>
<b>Complexity analysis.</b> Building the original G takes time O(S<b>R</b><b>C</b>) for S BFSes,
and the original matching takes time O((S+T)<sup>3</sup>) (there are faster algorithms for matching,
but Ford-Fulkerson is more widely known, simpler to code, and sufficient for this task).
After that, we have at most T steps of altering the matching and removing some parts of it.
Each of this steps requires building G', which takes time O(S<b>R</b><b>C</b>) for S BFSes,
and after that, all steps are linear in the size of the graphs G, G' or H, which are all bounded by
O((S+T)<sup>2</sup>). Notice that building G' is by far the slowest step, so you can use less
efficient implementations to manipulate the graphs without altering the time complexity. This gives
an overall complexity of O(TS<b>R</b><b>C</b> + (S+T)<sup>3</sup>). This is enough to solve the
problem, but it can be further refined by noticing each time we build G', the BFSes will reach the
same places or farther than in the previous step, so, if instead of restarting from scratch we
remember the BFSes and continue from where we were stopped before, we can reduce the total time
to build G' by a factor of T, down to O(S<b>R</b><b>C</b>), reducing the final complexity to
O(S<b>R</b><b>C</b> + (S+T)<sup>3</sup>).
</p>


  <div class="test-data-download-wrapper">
    <div class="test-data-download-header">
      <div class="test-data-download-header-text">Test Data</div>
      <div class="test-data-download-header-download-button">
        <a href="test_data.zip" target="_blank">
          <i class="material-icons grey">save_alt</i>
        </a>
      </div>
    </div>
    <div class="test-data-download-content">
      <div class="test-data-download-warning">
        <span class="material-icons" style="color: grey; vertical-align: middle;">info</span>
        <span style="vertical-align: middle;">We recommend that you practice debugging solutions without looking at the test data.</span>
      </div>
    </div>
  </div>



    </div>
  </body>
</html>
