
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Code Jam 2010 - Round 2</h3><h1>Analysis: Grazing Google Goats</h1><p>
This problem is tough from both the implementation side and the algorithm side.    In the analysis, we will begin by explaining some general concepts that show how the task is actually very similar to convex hull. We will then go into the particulars needed to build a solution and to prove that it is right. The resulting code isn't as scary as the length of the analysis makes you think.
</p>
<p>
Let us just focus on one bucket <b>Q</b> at a time. The problem asks us to choose rope lengths: i.e., for each pole position, we need to choose the radius of the circle centered at that pole. The common area will be the intersection of all these circles. It is clear that decreasing the radius of any circle will not increase the intersection. Therefore, we want the lengths to be as small as possible. Obviously, for each pole <b>P</b><sub>i</sub>, <b>P</b><sub>i</sub><b>Q</b> is the smallest length we can pick so that the goat can still reach the bucket. Our main task is to efficiently compute the common intersection area of these circles.
</p>
<p>
From the limits of this problem, it is also clear that computing the intersection in &Omega;(<b>N</b><sup>2</sup>) will be too slow. We are aiming for an algorithm that will, for each bucket, compute the intersection in time O(<b>N</b> log <b>N</b>).
</p>
<p>
The intersection is a convex shape where the boundary consists of arcs of the circles. One can prove in various ways (some of the reason will be obvious below) that each circle will only contribute at most one such arc. We will mostly focus on how to compute these arcs -- to which circle does it belong, where does it stop and where does it start. Once all this is computed, it is relatively easy to get the area.
</p>

<h3>Some theoretical background</h3>
<p>
While this section is not absolutely necessary for solving the problem, it will provide some nice insights. Once we have seen the problem from a few different angles, the solution will be conceptually clear and very natural.
</p>
<p>
So, first of all, note that all the circles we consider pass through a common point <b>Q</b>. If you have not seen it before, it is now our honor to introduce to you the beautiful geometric transformation called <i>inversion</i>. It takes <b>Q</b> as the center. And each point <b>X</b> &ne; <b>Q</b> is mapped to a point <b>X'</b> where <b>QX</b> and <b>QX'</b> are in the same direction, and the lengths satisfy <b>|QX|</b> <b>|QX'|</b> = 1.
</p>
<p>
Here is one very nice property of inversion: Every circle passing through the center point <b>Q</b> is mapped to a line that does not pass <b>Q</b>, and vice versa. And the interior of the circle is mapped to a half-plane that does not include <b>Q</b>. For our problem, the intersection of the <b>N</b> circles is then mapped to the intersection of <b>N</b> half-planes. For more details on inversion, we refer you to the <a href="http://en.wikipedia.org/wiki/Inversive_geometry" target="_blank">Wikipedia page on inversive geometry</a>.
</p>
<p>
We leave it to the reader to verify that, if the intersection is not empty, then we can rotate the plane such that <b>Q</b> is above all the half-planes. And the intersection of the half-planes is bounded by something called the <i>lower envelope of line arrangements</i>. The segments of the lower envelope are exactly the images of the arcs in the circle intersection from our original problem.
</p>
<p>
Then there is a concept of <i>duality</i> in computational geometry that maps each line <code>y = ax + b</code> to the point <code>(a, -b)</code>. The lower envelope is mapped by this transformation to the upper convex hull of the set of corresponding points.
</p>
<p>
So, our problem is indeed equivalent to the convex hull problem and the lower envelope of line arrangements problem. Both subjects are well studied and there are simple O(<b>N</b> log <b>N</b>) algorithms for both.
</p>
<p>
Out of these three settings, perhaps the algorithm for line arrangement is the simplest to visualize: Sort the lines by their slopes, and add them one by one. In each step, the existing lower envelope will be cut by the new line in two parts. The time for sorting is O(<b>N</b> log <b>N</b>), and the amortized complexity for the rest is O(<b>N</b>).
</p>

<h3>Solution to our problem</h3>
<p>
The previous section suggests a couple approaches that begin with explicitly doing an inversion about <b>Q</b>. In this section, we will discuss a direct solution to the problem, where we do not need to view the problem using the transformations from the previous section. Note that it will be in some ways equivalent to the above algorithm we introduced for line arrangements.
</p>
<p>
Let's look from <b>Q</b> along a straight ray. The intersection of this ray with each circle will be either just <b>Q</b>, or a segment between <b>Q</b> and the second intersection point of this ray with the boundary of the circle. That means that in order to build the area required in the problem statement, we need to find the circle "closest" to <b>Q</b> in each direction from it. Let's denote each direction by its polar angle, which is defined up to a multiple of 2&pi;.
</p>
<p>
We start by considering just one circle. Suppose the polar angle of a ray that goes from <b>Q</b> towards the center of that circle is &phi;. When the polar angle of a ray goes from &phi;-&pi;/2 towards &phi;, the distance from <b>Q</b> to the second intersection point with that ray increases from 0 to 
the diameter of the circle. When the polar angle continues from &phi; towards &phi;+&pi;/2, the distance decreases back to 0. When the polar angle changes from &phi;+&pi;/2 to &phi;+3&pi;/2 (the latter is the same as &phi;-&pi;/2, where we started), the intersection of the ray with the circle is just <b>Q</b>.
</p>
<p>
Now consider two circles, one with center at polar angle &phi; (remember, all polar angles discussed here are relative to <b>Q</b>) , another one with center at polar angle &xi;, and suppose 0 &lt; &phi; - &xi; &lt; &pi;. Then we'll see the following as we turn the ray originating from <b>Q</b>: starting from polar angle &xi;-&pi;/2 until &phi;-&pi;/2 the ray will intersect only the second circle; from &phi;-&pi;/2 the ray will intersect both circles, but the intersection point with the first circle will be closer to <b>Q</b> until the circles intersect; after the intersection and until &xi;+&pi;/2 the ray will still intersect both circles but the second is now closer; and from &xi;+&pi;/2 until &phi;+&pi;/2 the ray will only intersect the first circle.
</p>
<p>
The important thing about the two circles case discussed above is that in the range of polar angles where the ray intersects both circles (and that's exactly the range we care about in finding the intersection area). The situation is very simple: before the intersection point one circle is closer to <b>Q</b>, after the intersection point another circle is closer to <b>Q</b>.
</p>
<p>
Now suppose we have many circles. First, we find the polar angle of the center of each circle, and thus also find the range of polar angles where a ray going from <b>Q</b> intersects each of the circles. We can then intersect all those ranges of polar angles to obtain a small range [&alpha;, &beta;] of polar angles where the ray would intersect all circles. If this range is empty, then we already know there's no intersection.
</p>
<p>
Now let's start adding circles one by one, starting from the one with the smallest polar angle. You might ask, what does "smallest" mean when we're on a circle? Luckily, here we have less than full circle: since all circles intersect all rays in [&alpha;, &beta;] range, the polar angles of all centers are between &beta;-&pi;/2 and &alpha;+&pi;/2. That leaves us a segment of length less than &pi; where we have a definite order.
</p>
<p>
As we're adding the circles, we'll maintain which circle is closest for each angle from [&alpha;, &beta;]. For example, after adding the first circle it will be the closest for the entire [&alpha;, &beta;] range. Now we add the second circle. Let's say the polar angle of the intersection point between two circles is &gamma;. If you look carefully at the above analysis, you'll find that:</p><ul>
<li>When &gamma; is less than &alpha;, the first circle is still the closest for the entire [&alpha;, &beta;] .
<li>When &gamma; is between &alpha; and &beta;, the second circle is the closest for [&alpha;, &gamma;], and the first circle is the closest for [&gamma;, &beta;].
<li>When &gamma; is more than &beta;, the second circle is now closest for the entire [&alpha;, &beta;] .
</ul>
<p>
Here we rely on the fact that we process circles in increasing order of the polar angle of their center.
</p>
<p>
Now look at the general case. Suppose before adding circle number <code>i</code> we have the following picture: on [&alpha;, &gamma;<sub>1</sub>] circle <code>j<sub>1</sub></code> is the closest; on [&gamma;<sub>1</sub>, &gamma;<sub>2</sub>] circle <code>j<sub>2</sub></code> is the closest; ...; on [&gamma;<sub>k-1</sub>, &beta;] circle <code>j<sub>k</sub></code> is the closest.
</p>
<p>
Consider the polar angle &delta; of the intersection point between circle <code>i</code> and circle <code>j<sub>1</sub></code>. There are 3 ways it could compare with the range where <code>j<sub>1</sub></code> is the closest:
</p>
<ul>
<li>When &delta; is less than &alpha;, it means that circle <code>j<sub>1</sub></code> is closer than circle <code>i</code> on the entire [&alpha; &beta;] segment, and we can just stop processing circle <code>i</code> since it doesn't affect the answer.
<li>When &delta; is between &alpha; and &gamma;<sub>1</sub>, we now have that circle <code>i</code> is the closest on [&alpha;, &delta;], and circle <code>j<sub>1</sub></code> is the closest on [&delta;, &gamma;<sub>1</sub>]. After doing this change, we can also stop processing circle <code>i</code> since circle <code>j<sub>1</sub></code> will be closer to the center all the remaining way.
<li>Finally, when &delta; is more than &gamma;<sub>1</sub>, we can forget about circle <code>j<sub>1</sub></code> since circle <code>i</code> is closer than it on the entire [&alpha;, &gamma;<sub>1</sub>]  segment. In that case we continue processing circle <code>i</code> by comparing it with circle <code>j<sub>2</sub></code>, and so on.
</ul>
<p>
That's it! After we do this processing for all circles, we know the contour of the intersection figure, and we continue by computing its area.
</p>
<p>
The above algorithm requires a data structure that maintains a list of arcs with integer tags, allowing us to change the first arc, remove the first arc, and add a new first arc. The simplest way to get this data structure is to just use a stack where the first ac would be on the top, and the last one would be on the bottom.
</p>
<p>
The running time for the above algorithm can be estimated using amortized analysis as follows. When processing each circle, we do at most two "push to stack" operations, and one or more "pop from stack" operations. That means the total number of push operations is O(<b>N</b>), and since the number of pop operations can't be greater than the number of push operations (there'd be nothing to pop!), it's also O(<b>N</b>), giving us the total runtime of O(<b>N</b>). However, we must also remember the step where we sort all circles by the polar angle of their center, so overall runtime is O(<b>N</b> log <b>N</b>).
</p>
<p>
We've so far avoided discussing the low-level computational geometry needed for this problem. In the above solution we required two geometric routines: find the polar angle of the other intersection point of two circles which have the first intersection point at origin; and find the area of a figure that is bounded by arcs.
</p>
<p>
The first routine is straightforward if you can already intersect circles (a useful thing to know how to do!); alternatively, you could derive the formulas for the polar angle directly. The second one is slightly more tricky: first, we split the figure into "rounded triangles" with rays going from <b>Q</b> and having polar angles &gamma;<sub>1</sub>, &gamma;<sub>2</sub>, ..., &gamma;<sub>k-1</sub>. Each rounded triangle has two straight sides (one of those might have zero length) and one circular side. We can then split the rounded triangle into the corresponding triangle plus the round part (a sliced off part of a circle). You have probably seen how to compute the area of a triangle before - one good approach is the "shoelace formula". To calculate the rounded area, it helps to start with a "pie slice" from the center, whose area is a simple fraction of the total circle area, and then add or subtract triangle areas.
</p>
<p>
Of course there is a lot to do here, but that's why we made it Problem #4!
</p>

  <div class="test-data-download-wrapper">
    <div class="test-data-download-header">
      <div class="test-data-download-header-text">Test Data</div>
      <div class="test-data-download-header-download-button">
        <a href="test_data.zip" target="_blank">
          <i class="material-icons grey">save_alt</i>
        </a>
      </div>
    </div>
    <div class="test-data-download-content">
      <div class="test-data-download-warning">
        <span class="material-icons" style="color: grey; vertical-align: middle;">info</span>
        <span style="vertical-align: middle;">We recommend that you practice debugging solutions without looking at the test data.</span>
      </div>
    </div>
  </div>



    </div>
  </body>
</html>
