
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Code Jam 2010 - Round 1A</h3><h1>Analysis: Number Game</h1><p>
Let us begin by focusing on a single game. Given <b>A</b> and <b>B</b>, we can first assume without loss of generality that <code>A &ge; B</code>. Now, how can we decide if it is a winning position or not? (It is impossible to have a tie game since <code>A+B</code> is always decreasing.) Well, a position is winning if and only if, in one step, you can reach a losing position for your opponent. This is an important fact of combinatorial games, so make sure you understand why it's true!
</p>
<h3>Observations, easy and not so easy</h3>
<p>
One trivial observation is that <code>(A, A)</code> is a losing position.
</p>
<p>
Another observation is much trickier unless you have already been exposed to combinatorial games before:
<blockquote>
If <code>A &ge; 2B</code>, then <code>(A, B)</code> is a winning position.
</blockquote>
To justify this: in such a position, suppose <code>k</code> is the largest number of <code>B</code>'s we can subtract from <code>A</code>, i.e., <code>A - kB &ge; 0</code> and <code>A - (k+1)B &lt; 0</code>. We do not know yet whether <code>(A-kB, B)</code> is a winning position or not. But there are just two possibilities. If it is losing, great, we can subtract <code>kB</code> from <code>A</code>, and hand the bad position to our opponent. On the other hand, if it is winning, we can subtract <code>(k-1)B</code> from <code>A</code>, and our opponent has no choice but to subtract another <code>B</code> from the result, giving us the winning position <code>(A-kB, B)</code>. Therefore, <code>(A, B)</code> is a winning position either way!
</p>
<h3>Expand further</h3>
<p>
The observation above gives us a fairly quick algorithm to figure out who wins a single game <code>(A, B)</code>. Instead of using dynamic programming to solve the subproblem for all <code>(A', B')</code> with <code>A' &le; A</code> and <code>B' &le; B</code>, which is the most common way of analyzing this kind of game, we can do the following:<br/>
<ul>
<li>In round 1: If <code>A &ge; 2B</code>, it's a winning position and we're done. Otherwise, we have only one choice: subtract <code>B</code> from <code>A</code>, and give our opponent <code>(B, A-B)</code>.</li>
<li>In round 2: If <code>B &ge; 2(A-B)</code>, it is a winning position for our opponent. Otherwise, the only choice he has is to subtract <code>A-B</code> from <code>B</code>, and hand us <code>(A-B, 2B-A)</code>.</li>
<li>In round 3: If <code>A-B &ge; 2(2B-A)</code>, it is a winning position for us again. Otherwise, we are going to make it <code>(2B-A, 2A-3B)</code>.</li>
</ul>
And so on. This leads to the following algorithm for efficiently solving a single game <code>(A, B)</code>, assuming <code>A &ge; B</code>:
<pre>
  bool winning(int A, int B) {
    if (B == 0) return true;
    if (A &gt;= 2*B) return true;
    return !winning(B, A-B);
  }
</pre>
</p>
<p>
Does this sound familiar? One connection you might see is that the Number Game closely resembles Euclid's algorithm for greatest common divisor. It is not hard to see that this algorithm, like Euclid's, will need to recurse at most <code>O(log A)</code> times.
</p>
<p>
Unfortunately, we still cannot afford to run the algorithm for every possible <code>(A, B)</code>! To solve the problem, we need to work with many positions at once. Let us go through the same rounds, but imagine having a fixed B and consider all possible A's at the same time:
<ul>
<li> Round 1: <code>(A, B)</code>. If <code>A &ge; 2B</code>, i.e., <code>A/B &ge; 2</code>, then <code>(A, B)</code> is winning.</li>
<li> Round 2: <code>(B, A-B)</code>. If <code>B &ge; 2(A-B)</code>, i.e., <code>A/B &le; 3/2</code>, then <code>(A, B)</code> is losing.</li>
<li> Round 3: <code>(A-B, 2B-A)</codE>. If <code>A-B &ge; 2(2B-A)</code>, i.e., <code>A/B &ge; 5/3</code>, then <code>(A, B)</code> is wining.</li>
<li> Round 4: <code>(2B-A, 2A-3B)</code>. If <code>2B-A &ge; 2(2A-3B)</code>, i.e., <code>A/B &le; 8/5</code>, then <code>(A, B)</code> is losing.</li>
<li> And so on.</li>
</ul>
This gives a fast enough solution to our problem. For each <code>B</code>, we consider all <code>A</code>'s in the above manner, and in O(log 10<sup>6</sup>) rounds, we can classify all the <code>A</code>'s.
</p>

<h3>Simplify</h3>

<p>
The above method is perfectly correct, but it can be made simpler. First of all, does anything in the above list look familiar? There are Fibonacci numbers all over the place! Let <code>F(i)</code> be the <code>i</code>-th Fibonacci number. One can show by induction that the previous analysis is actually saying the following:
<ul>
<li> Round 2t-1: If <code>A/B &ge; F(2t+1)/F(2t)</code>, then <code>(A,B)</code> is a winning position.</li>
<li> Round 2t: If <code>A/B &le; F(2t+2)/F(2t+1)</code>, then <code>(A,B)</code> is a losing position.</li>
</ul>
It turns out that both <code>F(2t+1)/F(2t)</code> and <code>F(2t+2)/F(2t+1)</code> approach the golden ratio <code>&phi; = (1 + &radic; 5) / 2</code> as t gets large. This means there is a very simple characterization of all winning positions!

<blockquote>
<b>Theorem:</b> <code>(A, B)</code> is a winning position if and only if <code>A &ge; &phi; B</code>.
</blockquote>

Using this theorem, it is easy to solve the problem. Loop through each value for <code>B</code>, and count how many <code>A</code> values satisfy <code>A &ge; &phi; B</code>.

<h3>Why it is Golden?</h3>
<p>
Once we have stumbled upon the statement of this theorem, it is actually pretty easy to prove. Here is one method: Using mathematical induction, assume we proved the theorem for all smaller A's and B's. If <code>A &ge; 2B</code>, then <code>(A, B)</code> is a winning position as we discussed earlier. Otherwise we will leave our opponent with <code>(B, A-B)</code>. Then <code>(A, B)</code> is winning if and only if <code>(B, A-B)</code> is losing. By our inductive hypothesis, this is equivalent to <code>B &le; &phi; (A - B)</code>, or <code>A &ge; ((1 + &phi;) / &phi;) * B</code>. Since <code>&phi; = (1 + &phi;) / &phi;</code>, this proves <code>(A, B)</code> is winning if and only if <code>A &ge; &phi; B</code>, as required.
</p>
<p>
Here is another, more geometric viewpoint. You start with a piece of paper which is an <code>A</code> by <code>B</code> rectangle (<code>A &ge; B</code>), and cut out a <code>B</code> by <code>B</code> square from it. If the rectangle is <i>golden</i>, where <code>A = &phi;B</code>, then the resulting rectangle will also be golden. In our game, <code>A</code> and <code>B</code> are integers, so the rectangle is never golden. We call it <i>thin</i> if <code>A &gt; &phi;B</code>, otherwise we call it <i>fat</i>. From a thin rectangle you can always cut it to a fat rectangle, and from a fat one you can only cut it to a thin one. They correspond to the winning positions and losing positions, respectively.
<br/><br/>
&nbsp;&nbsp;&nbsp;<img src="golden.png"><br/>
&nbsp;&nbsp;&nbsp;A picture of golden rectangles from Wikipedia.
<br/><br/>
</p>

<h3>Other Approaches</h3>
<p>
There are many ways of arriving at the solution to this problem -- our analysis focuses on only one of these ways. Another approach would be to start with a slower method and compute which <code>(A, B)</code> are winning positions for small <code>A</code>, <code>B</code>. From looking at these results, you could easily guess that <code>(A, B)</code> is winning if and only if <code>A &ge; x B</code> for some <code>x</code>, and all that remains would be to figure out what <code>x</code> is!
</p>

<h3>More Information</h3>
<a href="http://www.google.com/search?q=euclid+algorithm" target="_blank">Euclid's Algorithm</a> -
<a href="http://www.google.com/search?q=fibonacci+numbers" target="_blank">Fibonacci Numbers</a> -
<a href="http://www.google.com/search?q=golden+ratio" target="_blank">Golden Ratio</a>


  <div class="test-data-download-wrapper">
    <div class="test-data-download-header">
      <div class="test-data-download-header-text">Test Data</div>
      <div class="test-data-download-header-download-button">
        <a href="test_data.zip" target="_blank">
          <i class="material-icons grey">save_alt</i>
        </a>
      </div>
    </div>
    <div class="test-data-download-content">
      <div class="test-data-download-warning">
        <span class="material-icons" style="color: grey; vertical-align: middle;">info</span>
        <span style="vertical-align: middle;">We recommend that you practice debugging solutions without looking at the test data.</span>
      </div>
    </div>
  </div>



    </div>
  </body>
</html>
