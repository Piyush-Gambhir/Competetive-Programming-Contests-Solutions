
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Code Jam 2013 - Round 3</h3><h1>Analysis: Observation Wheel</h1><h3>Small dataset</h3>

<p>In this problem we are interested in calculating the average amount of money we will make from filling up every gondola on our observation wheel. Because of linearity of expectation, this is equivalent to summing up the expected amount of money paid by each person. Given the fact that the amount a person pays doesn't depend on the order in which gondolas got occupied, we can represent the current free/occupied state of gondolas as a bitmask and use dynamic programming to solve the small case.</p>

<p>Let <b>E</b>(<b>mask</b>) be the expected amount of money we make starting from the configuration represented by <b>mask</b>, where 0 represents an empty gondola, and 1 represents an occupied gondola. A person has a probability of 1/<b>N</b> of starting at any given position. Once that starting position is fixed, we simply find the first 0 following it (in cyclic order), and that's where the person will eventually end up. </p>

<p>We'll define <b>f</b>(<b>i</b>) as the index of the gondola occupied by a person who starts at position <b>i</b>. Similarly, let <b>c</b>(<b>i</b>) be the amount of money this person pays, as per the problem statement. Then we have the following recurrence:</p>

<p><b>E</b>(<b>mask</b>)=1/<b>N</b>*&#8721;<sub><b>i</b>=0..<b>N</b>-1</sub>(<b>E</b>(<b>mask</b> | (1 &lt;&lt; <b>f</b>(<b>i</b>)) ) + <b>c</b>(<b>i</b>))</p>

<p>The bitwise operation here simply sets the bit corresponding to the gondola the user occupied. The base case is when there are no empty positions, in which case the expected amount of money is 0.</p>

<p>There are 2<sup><b>N</b></sup> states, each of which can be computed in linear time, so our time complexity is O(<b>N</b>*2<sup><b>N</b></sup>). This is pretty easy for the small data set, but unfortunately it's far too slow for the large case.</p>

<h3>Large dataset</h3>

<p>Let's analyze the problem from the end: one of our gondolas will be the last to become occupied, so we have several cases, one per each free gondola at the beginning. The expected amount of money we will get is equal to the sum of the expected amount of money we make in each of those cases multiplied by the probability of that case.</p>

<p>At first, it doesn't seem we've reduced the complexity of the problem: instead of having to find just the expected amount for the whole process, we now have to find both the expected amount and the probability for several cases! However, we can repeat the above trick. Take one of those cases, let's say that gondola <b>i</b> is the last to become occupied. Let's look at which gondola will be occupied directly before it. Let's say it's gondola <b>j</b>. And here's the breakthrough: as soon as we've fixed that gondolas <b>i</b> and <b>j</b> are the last two to become occupied, the observation wheel has been separated into two independent parts that don't affect each other: those between <b>i</b> and <b>j</b>, and those between <b>j</b> and <b>i</b>. They don't affect each other since <b>i</b> and <b>j</b> stay empty, and thus no person approaching one part of the wheel will end up in the other part.</p>

<p>Our approach in general will be to compute <b>E</b>(<b>i</b>, <b>j</b>), the expected amount of money we get from all gondolas from <b>i</b>-th until (<b>j</b>-1)-th, excluding <b>j</b>-th gondola itself which will stay empty. It is possible to have <b>i</b> &gt; <b>j</b> since we're dealing with a cyclic problem, so keep this in mind when implementing things. We basically start at <b>i</b> and proceed around the circle, stopping just short of <b>j</b>.</p>

<p>To compute expectations, we're going to need probabilities, so first let's look at <b>P</b>(<b>i</b>, <b>j</b>), the probability that <b>j</b>-th gondola will stay empty while we fill up all gondolas from the interval [<b>i</b>, <b>j</b>) assuming each coming person approaches some gondola in inteval [<b>i</b>, <b>j</b>] (note that j is included here). We can develop a recurrence to compute this.</p>

<p>Suppose we know that the last person enters the gondola at position (<b>i</b> + <b>k</b>). This splits the interval into two parts, with <b>a</b> empty squares on the left, <b>b</b> empty squares on the right, and 1 more empty square at (<b>i</b>+<b>k</b>). </p>

<img src="yiVNpBUiihL.png"/>

<p>The probability that gondola <b>j</b> stays empty while we fill interval [<b>i</b>, <b>j</b>) and that gondola at position (<b>i</b>+<b>k</b>) is filled last is <b>P</b>(<b>i</b>, <b>j</b>, <b>k</b>) and can be computed as:</p>

<p><b>P</b>(<b>i</b>, <b>j</b>, <b>k</b>) = <b>C</b>(<b>a</b>+<b>b</b>, <b>a</b>)*((<b>k</b>+1)/(<b>j</b>-<b>i</b>+1))<sup><b>a</b>+1</sup>*((<b>j</b>-<b>i</b>-<b>k</b>)/(<b>j</b>-<b>i</b>+1))<sup><b>b</b></sup>*<b>P</b>(<b>i</b>, <b>i</b>+<b>k</b>)*<b>P</b>(<b>i</b>+<b>k</b>+1, <b>j</b>)</p>

<p>Here <b>C</b>(<b>n</b>, <b>k</b>) is the binomial coefficient representing the number of ways to choose <b>k</b> objects from a set of <b>n</b>. The equation above amounts to choosing <b>a</b> people from (<b>a</b>+<b>b</b>) to go on the left side of the final empty space, and then making sure that (<b>a</b>+1) people go to the left side (including the person to fill up gondola <b>i</b>+<b>k</b>) and <b>b</b> people go to the right side. The probability that gondola <b>i</b>+<b>k</b> will stay empty is <b>P</b>(<b>i</b>, <b>i</b>+<b>k</b>), and the probability that gondola j will stay empty is <b>P</b>(<b>i</b>+<b>k</b>+1, <b>j</b>).</p> 

<p>This assumes that (<b>i</b>+<b>k</b>) is empty initially, otherwise we define <b>P</b>(<b>i</b>, <b>j</b>, <b>k</b>) = 0.</p>

<p>Of course, we can't actually fix the final person, but since every way to fill up the interval has some final person, we can just compute the probability that gondola <b>j</b> will stay empty as the sum of <b>P</b>(<b>i</b>, <b>j</b>, <b>k</b>) over all possible final positions <b>k</b>, giving:</p>

<p><b>P</b>(<b>i</b>, <b>j</b>)=&#8721;<sub><b>k</b>=0..<b>j</b>-<b>i</b>-1</sub><b>P</b>(<b>i</b>, <b>j</b>, <b>k</b>)</p>

<p>For our base case, we have <b>P</b>(<b>i</b>, <b>j</b>, <b>k</b>) = 1  if the interval [<b>i</b>, <b>j</b>) contains no free gondolas. This also includes the case where the interval is of size 0. Don't forget, we're still in a cyclic situation!</p>

<p>On to computing expectations! We'll use the same trick of splitting around the last person. The expected money we get while filling out the interval [<b>i</b>, <b>j</b>) so that the last filled gondola is at position (<b>i</b>+<b>k</b>) is:</p>

<p><b>E</b>(<b>i</b>, <b>j</b>, <b>k</b>) = <b>E</b>(<b>i</b>, <b>i</b>+<b>k</b>) + <b>E</b>(<b>i</b>+<b>k</b>+1, <b>j</b>) + <b>N</b> - <b>k</b>/2</p>

<p>Summing over all possible <b>k</b> to get the expectation, we get:</p>

<p><b>E</b>(<b>i</b>, <b>j</b>)=(&#8721;<sub><b>k</b>=0..<b>j</b>-<b>i</b>-1</sub><b>P</b>(<b>i</b>, <b>j</b>, <b>k</b>)*<b>E</b>(<b>i</b>, <b>j</b>, <b>k</b>))/<b>P</b>(<b>i</b>, <b>j</b>)</p>

<p>The way the first equation works is to combine the expectations from the left interval and the right interval, and then we need the expected number of skips to place the final person. There are (<b>k</b>+1) starting positions, corresponding to 0 skips, 1 skip, …, <b>k</b> skips. Each of these is equally likely, so the expectation is <b>N</b> - 1/(<b>k</b>+1)*(0 + 1 + ... + <b>k</b>)=<b>N</b> - <b>k</b>/2.</p>

<p>As before <b>E</b>(<b>i</b>, <b>j</b>, <b>k</b>) = 0 if gondola at position (<b>i</b>+<b>k</b>) is occupied.</p>

<p>To compute the final answer, we'll repeat the same trick in the final step. We try all possible empty positions as the last gondola to be filled and compute the expected number of skips. If the last empty position is i, then the expected money we get is:</p>

<p><b>P</b>(<b>i</b>+1, <b>i</b>)*(<b>E</b>(<b>i</b>+1, <b>i</b>) + (<b>N</b>+1)/2), </p>

<p>and the total expected amount of money is just the sum of this quantity over all empty positions.</p>

<p>This algorithm is O(<b>N</b><sup>3</sup>), which is easily within the time limit for the large case.</p> 


  <div class="test-data-download-wrapper">
    <div class="test-data-download-header">
      <div class="test-data-download-header-text">Test Data</div>
      <div class="test-data-download-header-download-button">
        <a href="test_data.zip" target="_blank">
          <i class="material-icons grey">save_alt</i>
        </a>
      </div>
    </div>
    <div class="test-data-download-content">
      <div class="test-data-download-warning">
        <span class="material-icons" style="color: grey; vertical-align: middle;">info</span>
        <span style="vertical-align: middle;">We recommend that you practice debugging solutions without looking at the test data.</span>
      </div>
    </div>
  </div>



    </div>
  </body>
</html>
