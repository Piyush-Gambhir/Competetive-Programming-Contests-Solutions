
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Code Jam 2013 - Qualification Round</h3><h1>Analysis: Fair and Square</h1><p>
The first thing to do in this problem (as in many other problems) is to make sure you read it carefully. Many contestants thought that 676 should be a fair and square number - after all, it is a square <b>and</b> a palindrome. It is <i>not</i>, however, a square <b>of</b> a palindrome, and this example is actually mentioned specifically in the problem statement!
</p>

<h3>The small input</h3>
<p>
Once you realize this, you can approach the small testcase by iterating over all the numbers Little John considers, and checking each one of them. You have to check for each number <b>X</b> whether it is a palindrome, and whether it is the square of a palindrome.
</p>
<p>
To check whether <b>X</b> is a palindrome, you can simply convert it to string format (the details here depend on the programming language you are using) and compare the first character to the last, the second to the second last, and so on.
</p>
<p>
To check whether <b>X</b> is the square of a palindrome, there are multiple options. One is to calculate the square root, and if the square root is an integer, check if it is a palindrome as described above. Another is simply to iterate over all numbers up to <b>X</b>, and for each palindrome, square it and see if the square is <b>X</b>. That's a perfectly good solution for the small input, but it will be too slow for the larger ones.
</p>

<h3>The first large input</h3>
<p>
For the first large input, we need to deal with numbers up to 10<sup>14</sup>, and also with 10,000 test cases. A linear search of all numbers up to 10<sup>14</sup> is not going to be fast enough, so we have to be smarter - we can't afford to check each number in the interval individually.
</p>
<p>
We don't really need to go all the way up to 10<sup>14</sup> though! We are interested in numbers whose <i>squares</i> are Fair and Square and between <b>A</b> and <b>B</b> - and that means we have to check up to the <i>square root</i> of <b>B</b> only. That's only 10<sup>7</sup> numbers to check in the worst case.
</p>
<p>
We are not done though. While 10<sup>7</sup> numbers can be processed within the time limit, processing 10,000 cases like this is somewhat risky. There are two tricks you can notice to make your solution faster.
</p>
<p>
One trick is that we are interested not in all the numbers up to 10<sup>7</sup>, but only in palindromes. We can generate all the palindromes much faster. Start by taking all the numbers up to 10<sup>4</sup>, and then taking their mirror reflections (either duplicating the last number or not) to generate all palindromes of length up to 8 (and then square each and check whether it is a Fair and Square number in the interesting interval). This will cause us to evaluate only around 10,000 numbers for each test case, which is small enough  that even a slow machine can deal with all the test cases in four minutes. You would need to use a reasonably efficient language however.
</p>
<p>
An alternative is to simply generate all the fair and square numbers up to 10<sup>14</sup> <i>before</i> processing the test cases. There are relatively few of them &mdash; it turns out only 39. Thus, if you find all of them (in any fashion) before downloading the input file, you can easily give the correct answers to all the input cases.</p>
<p>
Note that if you do this, you have to include the code you used to generate Fair and Square numbers - not just the code that includes the full list!
</p>
<h3>The second large data set</h3>
<p>
Now we come to the largest data set. Even combining both the tricks above is not enough - we need to go over 10<sup>25</sup> palindromes to precompute everything. This will take a very long time in any language on any computer! A good idea here is to generate the first few Fair and Square numbers (and their square roots) to try and get an idea of what they look like. There are two things you can notice:
</p>
<ul>
<li> All the Fair and Square numbers have an odd number of digits</li>
<li> All the digits are rather small. In particular, with one exception, every square root of a Fair and Square number consists only of digits 0, 1 and 2. </li>
</ul>
<p>
Let's try to understand why these things would be true.
</p>

<p>
Let's begin with the "odd number of digits". A square of a number with <b>N</b> digits will have either 2<b>N</b> - 1 or 2<b>N</b> digits, depending on whether there is a carry on the last position. Let's try to prove a carry never happens. 
Let <b>X</b> be Fair and Square, and let its square root be <b>Y</b>. Let the first digit of <b>Y</b> be <b>c</b> - then the first two digits of <b>X</b> are between <b>c</b><sup>2</sup> and (<b>c</b>+1)<sup>2</sup>. In particular:
</p>
<ul>
<li>If the first digit of <b>Y</b> is 1, the first digit of <b>X</b> is between 1 and 4 - and thus no carry.</li>
<li>If the first digit of <b>Y</b> is 2, the first digit of <b>X</b> is between 4 and 9 - and thus no carry.</li>
<li>If the first digit of <b>Y</b> is 3, the first digits of <b>X</b> are between 9 and 16, so the first digit is 9 or 1. As <b>Y</b> is a palindrome, the last digit of <b>Y</b> is 3 as well, and thus the last digit of <b>X</b> is 9 - meaning the first digit of <b>X</b> is 9 as well, meaning no carry.</li>
<li>If the first and last digit of <b>Y</b> is 4, the last digit of <b>X</b> is 6, while the first is either 1 or 2 - so <b>X</b> can't be Fair and Square.</li>
<li>Similarly, if the first and last digit of <b>Y</b> is 5 (last digit of <b>X</b> is 5, first is 2 or 3), 6 (last digit of <b>X</b> is 6, first is 3 or 4), 7 (last digit of <b>X</b> is 9, first is 4, 5 or 6), 8 (last digit of <b>X</b> is 4, first is 6, 7 or 8) and 9 (last digit of <b>X</b> is 1, first is 8 or 9), then <b>X</b> also can't be Fair and Square.</li>
</ul>
<p>
This means there is no carry in the first digit.
</p>

<p>
Now since all the digits seem so small, maybe this means there is no carry at all? Note that if you take a palindrome and square it, and there's no carry, the result is a palindrome as well - so that would give us a nice characterization of Fair and Square numbers. Indeed, it turns out to be the case, and the proof follows.
</p>

<p>
Let <b>Y</b> have digits (a<sub>d</sub>)(a<sub>d-1</sub>)...(a<sub>0</sub>). Let b<sub>k</sub> = a<sub>0</sub> * a<sub>k</sub> + a<sub>1</sub> * a<sub>k-1</sub> + ... + a<sub>k</sub> * a<sub>0</sub>. Note that b<sub>i</sub> is exactly the i<i>th</i> digit of <b>X</b> = <b>Y</b><sup>2</sup> when performing long multiplication, before carries are performed. Since a<sub>j</sub> = a<sub>d-j</sub>, we also have b<sub>i</sub> = b<sub>2d-i</sub>.<br/>
Now suppose there's a carry in the long multiplication (meaning some b<sub>j</sub> is greater than 9), and that we take a carry into digit i but no larger digits. We know digits i and 2d-i in <b>X</b> are equal, and are equal to b<sub>i</sub> plus whatever we carried into digit <i>i</i>. Since we carry nothing to digit i+1, b<sub>i</sub> is no larger than 9.<br/>
Now we will see that digit 2d-i of <b>X</b> has to equal b<sub>2d-i</sub> (which is equal to b<sub>i</sub>, and thus no larger than 9). For it to be different, we would have to carry something into digit 2d-i - but this would mean that b<sub>j</sub> is larger than 9 for some j &lt; 2d-i, and hence b<sub>2d-j</sub> is also greater than 9 and we would have a carry after digit i.<br/>
Since <b>X</b> is a palindrome, this tells us that digit i of <b>X</b> is equal to b<sub>i</sub>, which means that no carry entered digit i, and we have a contradiction.<br/>
We conclude that no carries were performed in the long multiplication at all.
</p>

<p>
Thus, the Fair and Square numbers are exactly the palindromes with no carries inside. In particular, the middle digit of <b>X</b> is the sum of squares of all the digits of <b>Y</b>, so this sum has to be no larger than nine. We conclude that only 0, 1, 2, and 3 can appear in <b>Y</b>.</p>

<p>
To find all Fair and Square numbers, it therefore suffices to consider only palindromes consisting of these four digits, with the sum of squares of digits 
at most 9. It turns out this is a small enough set that it can be directly searched, allowing us to generate the full list of all Fair and Square numbers up to 10<sup>100</sup> in a few seconds - and thus allowing us to solve the largest dataset.
</p>

<h3>Lessons learned</h3>
<p>
There are a few things we want to remind you of in the context of this problem:
</p>
<ul>
<li>It is really important to read the problem statement carefully.</li>
<li>We can sometimes have problems in which we don't have the standard combination of one small and one large input. The rules for dealing with small and large inputs are still the same (unless explicitly stated otherwise in the problem statement).</li>
<li>We can also sometimes give problems that require very large integers. We did give Fair Warning about this some time ago, but it's always worth reminding.</li>
<li>Finally, if you use precomputation in your solution, remember that you are required to provide us not only with the code that you actually used to solve the problem (containing the precomputed values), but also the code that you used for precomputation.</li>
</ul>


  <div class="test-data-download-wrapper">
    <div class="test-data-download-header">
      <div class="test-data-download-header-text">Test Data</div>
      <div class="test-data-download-header-download-button">
        <a href="test_data.zip" target="_blank">
          <i class="material-icons grey">save_alt</i>
        </a>
      </div>
    </div>
    <div class="test-data-download-content">
      <div class="test-data-download-warning">
        <span class="material-icons" style="color: grey; vertical-align: middle;">info</span>
        <span style="vertical-align: middle;">We recommend that you practice debugging solutions without looking at the test data.</span>
      </div>
    </div>
  </div>



    </div>
  </body>
</html>
