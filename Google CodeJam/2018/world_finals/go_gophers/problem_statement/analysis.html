
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Code Jam 2018 - World Finals</h3><h1>Analysis: Go, Gophers!</h1><p>
Let M = 25 be the maximum possible number of gophers.
</p>
<h3>Test set 1</h3>
<p>
Our approach to test set 1 will be as follows: first, we will find the minimum taste level among
all gophers, and then we will use it to determine the total number of gophers N.
</p><p>
To find the minimum taste level, we can simply
<a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">binary search</a>
using the question "is the minimum taste
level strictly greater than X?" This is equivalent to asking: "Would a snack of quality
X go uneaten by all gophers?" To answer such a question, we can offer 2M-1 snacks
of quality X consecutively, which guarantees that each gopher is exposed to at least one of them.
If none of those snacks are eaten, every gopher's taste level must be greater than X, but if
at least one snack is eaten, then there is at least one gopher with taste level at or below X.
We can even stop offering snacks as soon as one gets eaten, if we want to save some snacks.
This requires ceil(log 10<sup>6</sup>) &times; 49 = 980 snacks at the most.
</p><p>
Once we know that there is a gopher g with level exactly L, and that L is the minimum taste
level, we can use our snacks to answer a query "is it g's turn?" by offering a snack of quality L,
because g is the only gopher who would eat it. If we offer that many times in a row and calculate
the fraction of eaten snacks, that should approximate 1/number of gophers fairly well. At this
point, we might as well use our enormous number of leftover snacks to estimate, and then just
answer with the N such that the result is closest to 1/N. It turns out that M<sup>3</sup> tries of
this experiment guarantee that the answer is correct, even in the worst case. The proof is
included below as part of the explanation of the solution for test set 2.
</p>
<h3>Test set 2</h3>
<p>
The solution from test set 1 does not extend naturally to test set 2. In particular, it no longer
suffices to find out what fraction of gophers have the minimum (or maximum) taste level, because
there could be multiple gophers with that taste level; if we find a fraction of 1/K, the number
of gophers could be any multiple of K. So, we need to investigate other levels. Investigating taste
levels other than an extreme one brings about the problem of the result being impacted by gophers
with taste levels other than the one we are interested in.
We can still use the idea of answering general queries by repeating snacks
of the same quality, but they are significantly more complicated than a simple disjunction of the
snack outcomes.
</p><p>
The first query Q we describe is somewhat natural: What is the exact fraction of gophers with
taste level &ge; X?
</p><p>
Notice that this query alone is enough to solve the problem: we can do a binary search of sorts:
given a range [A, B] of at least two levels, and known fractions of gophers of those taste
levels X and Y, respectively, we can calculate the fraction of gophers Z for taste level
C = (A + B) / 2. We recurse over the range [A,C] if X &ne; Z and over the range
[C,B] if Y &ne; Z, because the fractions are different if and only if there is a gopher with a
taste level in the range producing the change.
This algorithm allows to identify all levels at which at least one gopher
exists. For each of them we calculate the fraction of gophers at level L using our query and then
subtracting the fraction of gophers at each other level &lt; L. Finally, we can take the
<a href="https://en.wikipedia.org/wiki/Least_common_multiple">least common multiple</a> (LCM) of
the denominators of all those fractions to find the answer.
</p><p>
This algorithm requires about N &times; ceil(log 10<sup>6</sup> - N) queries like Q to be
made. Unfortunately, we see below that this would be too many.
</p><p>
One way W1 of solving Q is to try enough snacks and then round to the nearest feasible fraction.
If we use enough snacks, the rounding will give the exact answer. Note that if we give X
consecutive snacks, we are guaranteed to have the right answer in all but a prefix and a suffix
of the tries, both of which have length up to M-1. This bounds the error by 2M-2. Moreover,
since our experiment has a binary answer, the farthest we can be from the true number of positive
(or negative) answers is M-1, in the case when there are exactly ceil(M/2) answers of one type
and floor(M/2) of the other, and we happen to hit both a prefix and suffix of size floor(M/2)
giving the same answer (this is for odd M, the worst case would be M for an even M).
</p><p>
Additionally, since we only consider fractions with denominators up to M, the distance between
two different results is bounded by 1 / (M &times; (M-1)). This means that if our experiment has
an error of less than half of that, rounding is guaranteed to produce the right answer. Putting
the total error of M together, this implies that we need M<sup>3</sup> snacks to get a perfect
answer for Q. A total number of snacks of
M &times; ceil(log 10<sup>6</sup> - M) &times; M<sup>3</sup> exceeds the allotted total by a large
margin.
</p><p>
A different way W2 to answer Q is to always use R consecutive snacks, where R is the LCM
of all the possible results. That means the error is always zero, since we give each gopher
exactly the same number of snacks. Unfortunately, LCM(2,3,...,25) is also much too large, so this
doesn't work either.
</p><p>
Another strategy to reduce the number of queries is to notice that we only need an exact number for
the final levels, right before doing the LCM to get the result. For all intermediate values of our
"multi-leaf binary search", we only need to decide whether there is some gopher in a range or not.
One way W3 to do it would be to, instead of using exact fractions X, Y and Z for A, B and C above,
have approximations X', Y' and Z' that are good enough that we can decide whether the real numbers
are equal. Using 2M<sup>2</sup> snacks guarantees that we will encounter each gopher at least 2M
times, which means that if X and Z are different, their approximations of the number of total
positives will differ by at least 2M. Since we showed that the total error of both approximations
is at most M-1, the error of the difference is at most 2M-1, which means comparing that difference
with 2M is enough to determine whether the real fractions
are equal or not. This significantly reduces the total required number of snacks, since we only
need to use M &times; ceil(log 10<sup>6</sup> - M) &times; M<sup>2</sup> for the multi-leaf
binary search, and then M &times; M<sup>3</sup> or M &times; R to get the final precise answers.
However, this is still too many.
</p><p>
The final algorithm requires us to use all 3 of the variants above: we start the multi-leaf binary
search using W3. Each time we find a level, we use either W1 or W2, whichever is cheapest, to
get the real fraction of the found level. If we recurse on the larger intervals first, we'll find
the levels from highest to lowest, so we can do the subtraction. Once we have the real fraction,
we potentially restrict the number of possible results N to the multiples of the denominator. This
reduces R. Eventually, R might be small enough that we can use W2 for the binary search instead of
W3 as well. Notice that each time we use W2, since we started with other methods, we need an
additional R to "align" ourselves, depending on how many snacks we have used so far. However, since
we eventually use R for everything, the additional cost of these alignments is extremely small.
</p><p>
We leave the precise analysis of total number of snacks needed to the reader, but it's possible,
with some careful bounding, to prove that it never exceeds <b>S</b>, and we couldn't find a case
that gets above ~85% of <b>S</b>. The reason is that if the denominator of a fraction is larger than
M/2, then there's only one possible result left and we are done. If it's less than M/2 but somewhat
large, the number of possibilities for the result is reduced significantly, and its LCM is reduced
even more because the GCD of those possibilities is more than 1. If the denominator is small, it
means that the found level has multiple gophers, which reduces the total cost of the multi-leaf
binary search.
</p>

    </div>
  </body>
</html>
