
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Code Jam 2018 - World Finals</h3><h1>Analysis: Swordmaster</h1><p>
  The only way we can fail to become the Swordmaster is to get stuck in a situation where for all
  remaining duelists (duelists that we have not beaten yet) we will not defeat them without learning
  additional skills. At any point in time, the remaining duelists can be divided into four groups:
  <ol>
    <li> D1: Duelists we certainly can defeat. </li>
    <li> D2: Duelists that have an attack we cannot defend against and a defense for every one of
         our attacks. </li>
    <li> D3: Duelists that do not have a defense for one of our attacks, but have an attack we
         cannot defend against. </li>
    <li> D4: Duelists that do not have an attack we cannot defend against, but have a defense for
         every one of our attacks. </li>
  </ol>
</p><p>
  If there is any remaining duelist in D1, we should just defeat them. If there is someone in D3 and
  there is someone in D4, then we can make some progress (i.e. reducing the number of remaining
  duelists, or moving a remaining duelist to D1) by doing the following:
  <ol>
    <li> We choose any duelist in D3 (call them A) and any duelist in D4 (call them B). </li>
    <li> We ask A for a duel. Since A is in D3, A has an attack that we don't defend against. Either
         A will use an attack that we don't defend against (thus we will learn the attack), or we
         can defend and win the duel (thus learning all of A's attacks). At the end of the duel, we
         will learn an attack which we can't defend against. Let us call this attack is <i>a</i>.
         </li>
    <li> If B cannot defend against <i>a</i>, then B has moved to D1 and we have made some progress.
         Otherwise, we ask B for a duel and use attack <i>a</i>. If B cannot defend, then we will
         win the duel and make some progress. Otherwise, we will learn defense <i>a</i>. </li>
    <li> Now that we have learned defense <i>a</i>, A might have moved to D1, or might still be in
         D3 (by having another attack that we can't defend against). If A moved to D1, then we have
         made progress. Otherwise, we repeat step 2 until A has no attack that we can't defend
         against. </li>
  </ol>
</p><p>
  Therefore, the only possibilities in which we might fail to become the Swordmaster are when either
  every remaining duelist is in D2 or D3, or every remaining duelist is in D2 or D4.
</p><p>
  If every remaining duelist is in D2 or D3, then every remaining duelist has an attack we can't
  defend. From this point, every remaining duelist can just attack us with an attack we can't defend
  against and choose to not defend against, which means that we will not learn any new defenses.
  Therefore, we can't defeat any more duelists and are certain to fail to become the Swordmaster.
  Notice that we can actually detect this situation up front &mdash; if there exists a group of
  duelists G<sub>1</sub> (not containing us), such that every duelist in G<sub>1</sub> has at least
  one attack against which nobody outside G<sub>1</sub> can defend, then we are doomed. The strategy
  for the duelists is that everybody in G<sub>1</sub> can just successfully attack us and choose to
  not defend (thus we are not learning any new defense known by duelists in G<sub>1</sub>).
</p><p>
  We can check the existence of G<sub>1</sub> by starting with G<sub>1</sub>', the set of all
  duelists except us. We can iteratively remove from G<sub>1</sub>' any duelist we can defend
  against regardless of their attack, and get all their defenses. This can be done in
  O(<b>N</b> &times; <b>P</b>) time. This complexity is also bounded by the sum of the number of
  attacks and defenses known to all duelists, which is linear in the size of the input.
</p>
<h3>Test set 1</h3>
<p>
  For test set 1, the situation when every remaining duelist is in D2 or D4 is similar. This means
  every remaining duelist can defend against all of our attacks. Therefore, there exists a group of
  duelists G<sub>2</sub> (not containing us), such that every duelist in G<sub>2</sub> has a defense
  for every attack available outside G<sub>2</sub>. Therefore, we are also doomed, since everybody
  in G<sub>2</sub> can just defend against our attack and always use attack 1 (thus we are not
  learning any new attack known by duelists in G<sub>2</sub>). We can check the existence of such
  G<sub>2</sub> up front with an algorithm analogous to the one presented above to check for
  G<sub>1</sub>.
</p>
<h3>Test set 2</h3>
<p>
  For test set 2, the situation when every remaining duelist is in D2 or D4 is complex. The
  difference is that our opponents <b>have to</b> attack, so even when dueling with some duelist who
  can defend against all of our attacks, we can learn a new attack. This new attack potentially
  causes some duelist to move from D4 to D1, or from D2 to D3. Therefore, the fact that every
  remaining duelist is in D2 or D4 is not a sufficient condition for us to fail to become the
  Swordmaster.
</p><p>
  Now imagine we are in a situation where we are actually doomed &mdash; we are in a position where,
  finally, every remaining duelist is in D2 or D4 and we will never defeat any duelist, nor will
  learn a new attack or defense. Such a situation has to be reached at some point since there is
  only a finite number of steps of learning (attack or defense) to be made. In this situation, we
  could fight a duel with every remaining duelist and learn the attacks they use. By definition, we
  already knew all these attacks, and so, also by definition, all our opponents can defend against
  all these attacks. So, for us to be doomed through this path, there must exist a group
  G<sub>2</sub> of duelists and an assignment of an attack for each of them
  <i>a</i> : G<sub>2</sub> -> Attacks, such that every duelist d in G<sub>2</sub> knows attack
  <i>a</i>(d) and knows how to defend against every attack known outside G<sub>2</sub> and every
  attack <i>a</i>(d') for d' in G<sub>2</sub>.
</p><p>
  This condition is harder to check. Let us assume there exists such G<sub>2</sub>. Consider any two
  duelists X and Y. If X has an attack that Y cannot defend against, then Y being in G<sub>2</sub>
  implies X must be in G<sub>2</sub> as well. This defines a directed graph on the duelists, with
  the edge going from Y to X.
</p><p>
  We find the <a href="https://en.wikipedia.org/wiki/Strongly_connected_component">
  strongly connected component</a>s (SCCs) of this graph. If any duelist of a SCC is in
  G<sub>2</sub>, then the whole SCC is in G<sub>2</sub>. Therefore, G<sub>2</sub> will be an upper
  subset (a subset with no edges going out of the subset) of the
  <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">directed acyclic graph</a> (DAG)
  of the strongly connected components of the graph. Notice that if we can choose some upper subset
  of duelists to be a valid set G<sub>2</sub>, then any subset of G<sub>2</sub> which is also an
  upper subset will also be a valid G<sub>2</sub> with the same attack selections. Therefore, it is
  enough to check only leaf SCCs in the DAG. If any valid G<sub>2</sub> exists, then a G<sub>2</sub>
  which is a leaf in the DAG also exists.
</p><p>
  Therefore, for each leaf SCC in the DAG, we can check whether each duelist in the SCC can choose
  an attack that every duelist in the SCC can defend against. To do this, we can first find the set
  <i>D</i> which is an intersection of the defenses known by every duelist in the SCC, and see
  whether every duelist in the SCC has an attack in <i>D</i>.
</p><p>
  To construct the graph in O(<b>N</b> &times; <b>P</b>) time, we can introduce nodes for attacks as
  well. We add an edge from a duelist to an attack if the duelist cannot defend against the attack,
  and an edge from an attack to a duelist if the duelist knows that attack. The overall solution
  runs in O(<b>N</b> &times; <b>P</b>) time.
</p>


  <div class="test-data-download-wrapper">
    <div class="test-data-download-header">
      <div class="test-data-download-header-text">Test Data</div>
      <div class="test-data-download-header-download-button">
        <a href="test_data.zip" target="_blank">
          <i class="material-icons grey">save_alt</i>
        </a>
      </div>
    </div>
    <div class="test-data-download-content">
      <div class="test-data-download-warning">
        <span class="material-icons" style="color: grey; vertical-align: middle;">info</span>
        <span style="vertical-align: middle;">We recommend that you practice debugging solutions without looking at the test data.</span>
      </div>
    </div>
  </div>



    </div>
  </body>
</html>
