
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Code Jam 2018 - Round 3</h3><h1>Analysis: Name-Preserving Network</h1><h3>How hard can this be?</h3>
<p>
  At first glance, test set 1 may seem to be approachable even by hand, since
  only one design is required, and we have considerable flexibility in the
  number of computers to use. But it turns out to be difficult to satisfy all
  of the following at once:
</p>
<ul>
  <li>Each computer must use exactly 4 links.</li>
  <li>The network must be connected.</li>
  <li>The computers must be uniquely distinguishable even after their IDs are
    permuted, and we must know how to distinguish them.</li>
</ul>
<p>
  For example, we might try creating a ring of computers in which each one is
  linked to its two neighbors and neighbors' neighbors. This satisfies the
  4-link and connected conditions. But this design is highly symmetric in a
  way that makes the computers less distinguishable. We can try introducing
  some irregularities (by swapping some edges around; more on this later) to
  disrupt the symmetry, but then it becomes even harder to eyeball the design
  &mdash; and how can we "find" our computer again after the judge has permuted
  their identities?
</p>
<h3>Harder than it looks</h3>
<p>
  We need a way to give each computer a unique label. Labels need to be such that:
</p><ul>
<li>They are id-agnostic &mdash; that is, the label of a computer depends only on the link
  topology, and not on its own or other computers' ids.</li>
<li>There exist networks such that each computer has a unique label, and moreover, we can
  somewhat efficiently find those networks.</li>
  <li>We can efficiently compute the labels of a given network.</li>
</ul><p>
If we have a labeling scheme that has all these properties, the solution writes itself:
find a network of appropriate size, compute the labels on it and the labels on the shuffled
network given by the judge, and match the computers by label.
</p><p>
There are many possible labeling schemes, and experimentation can go a long way to find them. We
describe two below, one for the theoretically inclined, and one more manual.
There also exist ways to explicitly construct networks that guarantee a particular
labeling scheme. Both the constructions and labeling schemes are somewhat complicated
and require casework, and only those constructions with labeling schemes that are quick
to compute will work for this problem. Constructions are of course significantly easier for
Test set 1, as we only need to build one network and we and we can use whichever network size
(between 10 and 50) we want.
</p><p>
Let us start with the theoretical one, since it's shorter to write. We can model
the network as an undirected graph in which each node has degree 4. If we take the
<a href="https://en.wikipedia.org/wiki/Adjacency_matrix">adjacency matrix</a> of the
graph and compute its p-th power, we obtain a matrix in which cell (i,j) gives the
number of paths of length p between nodes i and j. In the context of this problem, we do not particularly care about these paths per se, but we do care that the count of paths for a pair of nodes (i,j) depends on the entire topology of the network. So, if we are lucky enough,
the set of values (i,1), (i,2), ... will be unique for each i. As it turns out,
most graphs of a given size yield unique levels for p = 7, and quite possibly for other
values as well.
We generated graphs for every size between 10 and 50 and only needed to try a second
time twice, and never a third time.
</p><p>
For a more manual approach, we can start by noticing that all computers
look similar if we focus on them in isolation; they all use four outgoing
links. The same is true of each of a computer's four neighbors. But what if
we look at how the neighbors are connected to each other? Specifically, let
us label a computer X via a multiset of four values Y<sub>i</sub>, one for
each computer linked to X, where Y<sub>i</sub> is the number of other
computers that are neighbors of both X and Y<sub>i</sub>. For example,
suppose that computer 1 is directly linked to computers 2, 3, 4, and 5, and
that there are additional direct links 2-3, 2-4, and 4-5 (and all other links
from 2, 3, 4, and 5 are to other computers). Then our multiset for computer
1 would be {1, 1, 2, 2}.
</p><p>
  This labeling will not get us far enough in distinguishing computers, since
  there are not many possible labels of the form described above. But we can
  take this approach deeper! Let us label each computer as described above,
  and call those the level 1 labels. Then, we give each computer a level 2
  label that is defined as the multiset of the level 1 labels of its neighbors
  &mdash; that is, each level 2 label is a multiset of four multisets. We can
  even go on to add a level 3 label that is the multiset of the neighbors'
  level 2 labels, and so on. It turns out that level 4 labels give us enough
  power to tell computers apart, at least within the 10 to 50 computer range.
  Moreover, since labeling a computer only requires looking at a computer's
  four neighbors and a finite number of possible connections between them, one
  round of the labeling process takes O(computers) time, as does the full
  process of getting the level 4 labels. This is more efficient than other
  possible approaches that, e.g., label a computer by the smallest or largest
  cycle it is part of.
</p><p>
  Armed with either labeling method, we just need a way to create network designs
  to try them on. Generating edges at random has a really low probability of making
  all degrees exactly 4, so we need something better. One simple possibility is to
  shuffle a list of exactly 4 times each id, and link the first two ids, the third and
  fourth, and so on. If this creates a self-loop or a repeated link, repeat until it
  doesn't. The probability of self-loops or repeated edges is small enough for this to
  finish quickly for every size.
</p><p>
  Another way to generate graphs that is less chaotic is to start with the ring design
  mentioned above, and then repeatedly mutate it as follows:
</p>
<ol>
  <li>Randomly select a computer A and one of its neighbors B.</li>
  <li>Randomly select a neighbor C of A and a neighbor D of B, such that C is
    not already a neighbor of B, and D is not already a neighbor of A.</li>
  <li>Delete the links A-C and B-D, and add the links A-D and B-C.</li>
</ol>
<p>
  This mutation method guarantees that each computer always has four links, and
  that the network remains connected. (Since we had C-A-B-D before and we have
  C-B-A-D after, any two computers that were directly or indirectly connected
  before are still connected.)
</p><p>
  Most networks generated in this way (after, e.g., 1000 mutations) turn out to
  have unique labels on the computers. When we get one that does not (either
  because the network has some inherent symmetry, or because our labeling
  method isn't powerful enough for the network), we can just throw it away and
  try again. Our strategy should take at most a few seconds to discover usable
  network designs for all possible test cases, and then the rest is just
  implementation of interactions with the judge.
</p><p>
  Finally, notice that, if necessary, graphs for all necessary sizes could be pre-computed
  offline and hardcoded into the solution. As long as the labeling
  method is efficient, it is OK for the process of finding the graphs to be a bit slow, as
  long as it finishes within the contest time! Nevertheless, all ideas presented above are
  fast enough to require no pre-computation.
</p>

    </div>
  </body>
</html>
