
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Code Jam 2018 - Round 3</h3><h1>Analysis: Fence Construction</h1><p>
For both solutions discussed below, we model the situation as a
<a href="https://en.wikipedia.org/wiki/Planar_graph">planar graph</a> G with endpoints as nodes
and fences as edges. Getting a representation of this graph as an adjacency list takes quasilinear
time on the input (because we need to identify endpoints, which may add a logarithmic factor
or an expected constant factor depending on whether we use trees, hashing or sorting to do it).
</p>
<h3>Test set 1</h3>
<p>
Let us assume for a brief moment that there is no prescribed partial ordering
(for instance, when <b>K</b> = 1). There are many greedy algorithms that would retrieve a correct
ordering of the fences. You can try working the fences from the outside in or from the inside out,
cleverly using
<a href="https://en.wikipedia.org/wiki/Convex_hull">convex-hull</a>-type algorithms.
Each way has its own pros and cons, but many of them
also have the property that the reverse of the ordering they produce is also a valid ordering.
This is enough to deal with <b>K</b> up to 2: retrieve a greedy order. If the partial order is
obeyed, return that; otherwise, return the reverse. One of the two is guaranteed to work.
Another way that works for some greedy alternatives is that they may allow us to fix a single fence
as the first one to be built and then work from there. If you fix fence 1 to be the first one
built, the partial order is guaranteed to be respected.
</p><p>
We will describe a different option than the one discussed above, because it is simpler
to describe, prove and implement. Build any
<a href="https://en.wikipedia.org/wiki/Spanning_tree">spanning tree</a> T of G that contains
fence 1. Build the fences in T first in any order that starts with fence 1. This guarantees that we
respect the partial order.
Since we are building fences that close no cycle, there are no restrictions to moving the printer
so far: any point not on a fence is reachable.
</p><p>
For each the remaining fences f, consider the cycle that is formed when f is added to T. That cycle
represents a <a href="https://en.wikipedia.org/wiki/Simple_polygon">simple polygon</a>.
If we simply build these remaining fences in increasing order of area
of that polygon (breaking ties arbitrarily) we obtain a valid order. The reason is that we can
always keep the printer on the "outside" of all closed cycles. Since the next cycle to be closed
at any time has area no less than any already closed cycles, it cannot be contained in any of them,
which means the fence that is closing it is also on the "outside", and so the printer can get
arbitrarily close to the fence's position and find a point from where the fence can be built.
</p><p>
Notice that this algorithm can be implemented in quadratic time. Building a spanning tree takes
linear time. For each fence outside of the spanning tree, we take linear time to get the area
of the polygon, which leads to quadratic overall. Then, we only need to sort the remaining fences,
which can be done in faster-than-quadratic time.
</p>
<h3>Test set 2</h3>
<p>
For Test set 2, a bit of theoretical knowledge is required.
Build the <a href="https://en.wikipedia.org/wiki/Dual_graph">dual</a> graph
of G and call it H. Moreover, let G(S) and H(S) be the graph corresponding to
a given set of fences S and its dual, respectively.
As usual, when we name faces or nodes of H, we include the face that is on
the outside (i.e., the only one with infinite area).
</p><p>
When we finish our work, the printer will be left in one of the faces of G,
that is, one of the nodes of H, and the last fence we built will be one of the edges that are
adjacent to that face. If we step through the build order backwards,
right before building the last fence f,
the printer is on a face of G(F - {f}), where F is the set of all the fences. For any set S
and any fence f, there is a strong relationship between G(S) and G(S - {f}), and correspondingly,
H(S) and H(S - {f}). G(S - {f}) is the result of removing f, and possibly its endpoints if they
become isolated, from G(S). Correspondingly, H(S - {f}) is either equal to H(S) or the result
of merging two nodes of H(S) into one: f may have a single adjacent face in G(S) or two,
which leads to nothing changing or two nodes merging in H(S), respectively.
</p><p>
Focusing back on G(F - {f}), we know that the next-to-last fence g to be built has to be one of the
fences that is adjacent to a face adjacent to f. The one right before that is adjacent to a face
adjacent to either f or g, and so on. That means any ordering of the fences is a possible search
on the graph X of fences as nodes where two fences are adjacent in X if they are adjacent to the
same face of G. A search on a graph is an ordering of the nodes such that any prefix of the
ordering is connected. Breadth-first-searches and depth-first-searches are examples of searches,
but not the only ones.
</p><p>
Now that we have identified valid orders with searches on a graph,
we can greedily build one that respects the partial order. From this point on, we will build
the reverse of the output. Let us fix the first fence of our order f.
From here, we can keep track of the reached fences. Any reached fence that is not in the partial
order can be added immediately to our order, as it only adds more reachable fences and it cannot
violate the partial order. Fences that are in the partial order, however, need to be added
respecting that, which we can also do greedily. If at some point all the reachable fences are in
the partial order but neither is the next one, we have failed and we need to choose a different f.
</p><p>
The explanations above lead to a quadratic algorithm: building G and then H takes quasilinear
time. Building X from H takes quadratic time (since it may have a
quadratic number of edges). The greedy algorithm takes constant time for each fence it adds to the
order, and we may need to try a linear number of starting fences f, so that time is quadratic
overall.
</p><p>
The algorithm can actually be improved to quasilinear overall: there is no need to build X
explicitly. We can use X implicitly from H and only inspect adjacencies to fences that haven't been
reached. That removes the quadratic cost of explicitly building X. As for trying every f,
we can prove that fixing f to be the first fence in the partial order (that is, fence <b>K</b>,
since we are building a reverse order) is always optimal. For a valid search of X that respects the
partial order, reversing the prefix that ends on fence <b>K</b> is also a valid search that
respects the partial order, and has fence <b>K</b> first.
</p>


  <div class="test-data-download-wrapper">
    <div class="test-data-download-header">
      <div class="test-data-download-header-text">Test Data</div>
      <div class="test-data-download-header-download-button">
        <a href="test_data.zip" target="_blank">
          <i class="material-icons grey">save_alt</i>
        </a>
      </div>
    </div>
    <div class="test-data-download-content">
      <div class="test-data-download-warning">
        <span class="material-icons" style="color: grey; vertical-align: middle;">info</span>
        <span style="vertical-align: middle;">We recommend that you practice debugging solutions without looking at the test data.</span>
      </div>
    </div>
  </div>



    </div>
  </body>
</html>
