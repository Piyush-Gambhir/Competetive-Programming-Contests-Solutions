
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Code Jam 2019 - Round 3</h3><h1>Analysis: Datacenter Duplex</h1><p>
We can start by modeling the problem as a graph where each cell of the input matrix represents
a node. Orthogonally adjacent cells with the same label are connected by edges, and we can
optionally add edges connecting diagonally adjacent cells with the same label. The goal is to
end up with exactly two
<a href="https://en.wikipedia.org/wiki/Connected_component_(graph_theory)">connected components</a>.
</p>
<h3>Test set 1</h3>
<p>
Test set 1 can be solved with
<a href="https://en.wikipedia.org/wiki/Dynamic_programming">dynamic programming</a>,
iterating over columns. When considering the i-th column from left to right,
we can summarize the state of the connections we have added in the submatrix S of columns 1
through i by recording:
(1) whether we have seen (at least one cell of) each of A and B so far, and (2) whether any
two cells on the i-th column that contain the same label but are not orthogonally adjacent are
connected by a path in S. Then, we can use brute force, and consider all possible
choices of how to connect each of the up to 3 cell corners between columns i and i+1
(there are at most 4 rows in Test set 1). There are 3 possibilities for each corner, \, / and
no connection, but it can be reduced by noticing if at least one of the connections is valid, it is
always optimal to use one, which reduces the number of choices per corner to 2 at the most. If
at any point we discover a new isolated A component that cannot be connected to previously seen As,
we have failed, and same is true for B. If we finish, we can then use a second pass to reconstruct
one choice of diagonal connections that led to solving the problem.
</p><p>
This seemingly simple idea has several technical details that we are omitting here.
Some of them can be simplified by
starting and ending the process in columns that contain both As and Bs and preprocessing
to check if any leftmost or rightmost columns that contain only one type already disconnect
the other type.
</p><p>
The overall time complexity of this solution is exponential in <b>R</b>, because we are trying all
combinations of O(<b>R</b>) corners and recording the connected status of O(<b>R</b>) cells
at each state, and linear in <b>C</b>,
with the exact formula depending on how the technical details are handled. As long as the base of
the exponential factor is not too large, this is fast enough to pass within the
time limit.
</p>
<h3>Test set 2</h3>
<p>
The key observation is: after we decide to add some edges (diagonal adjacencies),
two cells c and d containing the same label X end up separated regardless of
any future decisions if and only if one of the following two conditions holds:
</p><ul>
<li>1. There is a cycle of cells labeled Y &ne; X in the graph, with one of c and d
being inside the cycle and the other one being outside.</li>
<li>2. There is a path of cells labeled Y &ne; X in the graph with the first and
last cells of the path being border cells of the matrix, with c and d being on opposite sides of
the path.</li>
</ul><p>
Let us use G to denote the graph with no diagonal edges added and H to denote
the final graph with all edges added. Consider the border of the matrix.
Suppose that it contains two cells c and d labeled X that are not connected in G. Since they
are not connected in G, that means, going around the border, there are cells e and f labeled
Y &ne; X such that e is in between c and d in clockwise order and f is between c and d in
counter-clockwise order. That means neither c and d nor e and f can be connected in H
with a path of only border cells. Therefore, if c and d are connected in H, the path connecting
them disconnects e and f, and vice versa. So, by the second condition, having two cells on the
border with the same label that are disconnected in G results in an impossible case.
</p><p>
Notice that there is never an incentive to generate an edge from a diagonal adjacency to connect
two cells that are already connected. Per the paragraph above, if a case is possible, then
all border cells with the same label are already connected in G. Therefore, if an algorithm
never adds an edge from a diagonal adjacency that connects two cells that are already
connected, it will never generate a path between two border cells.
Additionally, if we never connect cells that are already connected, any cycle in H is a cycle
that was already present in G, so again, if we end up in a disconnected situation, the case must
have been impossible from the start, before we added any connections.
</p><p>
These observations directly suggest the following algorithm: consider each diagonal adjacency
and generate an edge if and only if it will connect two previously disconnected cells. If both
choices work, we can choose either, since we already established that the decision of not connecting
previously connected cells is enough to guarantee an algorithm will not generate an H with more
than 2 connected components when a different one with exactly 2 was possible. After this process,
check if there are 2 connected components or more than 2, and print the results.
</p><p>
If we implement the algorithm above using a
<a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">union-find</a> to maintain
the connected components, we need O(<b>R</b> &times; <b>C</b>) checks for whether two cells
are connected and O(<b>R</b> &times; <b>C</b>) connections (joins). Since union-find provides
almost constant amortized time for both operations, the overall time complexity of the algorithm
is quasilinear.
</p><p>
An equivalent algorithm is to calculate the connected components of G first and then use shortest
paths to join any two components of the same label until we cannot do it anymore. Since shortest
paths cannot create new cycles, an argument similar to the one above proves that this
solution is also correct. This solution can be implemented in linear time if the partial minimum
path tree graph is reused for each new connection we need.
</p>

    </div>
  </body>
</html>
