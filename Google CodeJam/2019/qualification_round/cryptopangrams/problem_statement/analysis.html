
<html>
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,Safe"></script>
    <script>
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$$$','$$$'] ],
          displayMath: [ ['$$$$','$$$$'] ],
          skipTags: ["script","noscript","style","textarea","pre"],  // allow <code>.
          processEscapes: true
        },
        showProcessingMessages: false,
        messageStyle: "none",
        "HTML-CSS": { scale: 90, fonts: ["TeX"] }
      });
      MathJax.Ajax.loadComplete('https://codingcompetitions.withgoogle.com/static/mathjax-config.js');
      </script>
    <style>
.problem-io-wrapper-new .sampleio-wrapper {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  margin-top: 1rem;
  padding-left: 12.5px;
  padding-right: 12.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-input {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: -12.5px;
  margin-right: 12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-output {
  display: flex;
  flex-direction: column;
  flex: 1 1 0px;
  margin-left: 12.5px;
  margin-right: -12.5px;
  max-width: 50%;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-text {
  flex: 1;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-download-button {
  display: none;
  cursor: pointer;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button {
  display: none;
  cursor: pointer;
  position: relative;
  margin-left: 5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup {
  visibility: hidden;
  width: 100px;
  background-color: #999;
  color: #fff;
  text-align: center;
  border-radius: 3px;
  padding: 4px 0;
  position: absolute;
  z-index: 1;
  top: 125%;
  left: 50%;
  margin-left: -50px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup::before {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: transparent transparent #999 transparent;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button .sample-header-copy-popup-shown {
  visibility: visible;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-header .sample-header-copy-button-hidden {
  display: none;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content {
  display: flex;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 0px 9.5px;
}
.problem-io-wrapper-new .sampleio-wrapper .sample-content .sample-content-text {
  flex-grow: 1;
  margin: 0px;
  overflow-x: auto;
  padding-bottom: 9.5px;
  line-height: normal;
  white-space: pre-wrap;
}
.test-data-download-wrapper {
  display: none;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  width: fit-content;
  max-width: 600px;
  margin-top: 1rem;
}
.test-data-download-wrapper .test-data-download-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-text {
  flex: 1;
}
.test-data-download-wrapper .test-data-download-header .test-data-download-header-download-button {
  display: none;
  cursor: pointer;
}
.test-data-download-wrapper .test-data-download-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #f5f5f5;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  max-width: 600px;
  margin-top: 1rem;
}
.sample-interaction-wrapper .sample-interaction-header {
  display: flex;
  flex-direction: row;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  border-top: 1px solid #ccc;
  border-radius: 4px 4px 0px 0px;
  padding: 9.5px 9.5px 7px 9.5px;
  font-family: 'Google Sans';
  font-size: 1.2rem;
  font-weight: 300;
}
.sample-interaction-wrapper .sample-interaction-header .sample-interaction-text {
  flex: 1;
}
.sample-interaction-wrapper .sample-interaction-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 0px 0px 4px 4px;
  background-color: #e6e6e6;
  padding: 9.5px 9.5px 9.5px 9.5px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-judge-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: left;
  flex-grow: 1;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-solution-labels .sample-interaction-solution-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: right;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper {
  display: flex;
  flex-direction: row;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-output-wrapper .sample-interaction-judge-output-box .sample-interaction-judge-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper {
  display: flex;
  flex-direction: row-reverse;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box {
  text-align: start;
  background: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 4px 8px;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-output-wrapper .sample-interaction-solution-output-box .sample-interaction-solution-output-test {
  margin: 0;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-judge-note {
  font-style: italic;
  color: #4e4e4e;
  margin-right: 20%;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-solution-note {
  font-style: italic;
  color: #4e4e4e;
  margin-left: 20%;
  text-align: end;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-section-label {
  font-weight: bold;
  color: #4e4e4e;
  text-align: center;
}
.sample-interaction-wrapper .sample-interaction-content .sample-interaction-block-spacer {
  height: 9.5px;
}
    </style>
  </head>
  <body>
    <div>
<h3>Code Jam 2019 - Qualification Round</h3><h1>Analysis: Cryptopangrams</h1><h3>Yeah, but what about <i>de</i>crypting?</h3>
<p>
  The statement tells us how the plaintext is encrypted, but it says nothing
  about the decryption mechanism! Figuring that out is part of the problem.
  Since this is a Qualification Round problem, there is slightly less time
  pressure and competitive urgency, and you have some extra time to think
  about how this cryptosystem is supposed to be used.
</p><p>
  Suppose that Cameron and Jamie are members of the Code Jam team who know
  the secret list of 26 primes, and suppose that Cameron has just sent the
  ciphertext to Jamie. Each value in the ciphertext is the product of two
  of those primes, so Jamie can try dividing each value by each known prime
  to find the value's factors. (Notice that a value in the ciphertext might be
  the square of a prime, if the plaintext has the same letter twice in a row.)
</p><p>
  After getting the list of factored ciphertext values, how should Jamie
  recover the plaintext? We might be tempted to say that the second letter of
  the plaintext is the one whose prime appears as factors of both the first
  and second ciphertext values, the third letter is the one whose prime
  appears as factors of both the second and third ciphertext values, and so
  on. Then the remaining factors in the first and last ciphertext values give
  us the first and last letters of the plaintext.
</p><p>
  This is almost correct, but we (and Jamie) would have to deal with one
  significant annoyance. If the plaintext starts with something like
  <code>ABABA</code>..., for example, then the first, second, third, and
  fourth ciphertext values will all be the same, being the product of the same
  two factors (the primes corresponding to <code>A</code> and <code>B</code>).
  In particular, the start of <code>BABAB</code>... looks just the same as
  the start of <code>ABABA</code>...! The good news is that we know that this
  kind of pattern must terminate somewhere in the message; eventually, either
  we will get the same letter twice in a row, or (since the plaintext uses
  more than two different letters) three consecutive different letters. As soon
  as either of these things happens, we have a "break-in point", and we
  know which factors of a particular ciphertext value go with which of the
  two letters of the plaintext that it encodes. Then, we can "unzip" the rest
  of the plaintext from there, working backwards and forwards.
</p><p>
  For instance, if the plaintext starts with <code>ABABAABAB</code>, the first
  four ciphertext values will all be the same: the product of the prime
  corresponding to <code>A</code> and the prime corresponding to
  <code>B</code>. The fifth ciphertext value will represent the square of
  <code>A</code>, so we will know that the fifth and sixth plaintext letters
  are both <code>A</code>. We can then reason that the fourth plaintext letter
  must be the fourth ciphertext value divided by the prime corresponding to
  <code>A</code>, the third plaintext letter must be the third ciphertext
  value divided by the prime corresponding to <code>B</code>, and so on going
  backwards. We can also determine that the seventh plaintext letter is the
  sixth ciphertext value divided by the prime corresponding to <code>A</code>,
  and so on going forwards.
</p><p>
  Similarly, if the plaintext starts with <code>ABABCBABA</code>, when we
  inspect the third and fourth ciphertext values, we will see that they are
  different, but both have the prime corresponding to <code>B</code> as a
  factor. Then we can unzip from there, as above.
</p><p>
  However, we must remember that Jamie has an advantage that we do not have:
  we do not know the 26 secret primes! We need to find a way to get them.
</p>
<h3>Test set 1</h3>
<p>
  In test set 1, the ciphertext values are products of small primes. Each
  prime is less than 10<sup>4</sup>, so each ciphertext value is no larger than
  10<sup>8</sup>. It is straightforward to factor these values by testing
  every possible (prime) factor between 2 and 10<sup>4</sup>. Once we have all
  of the factors, we will have our set of 26 primes, since each prime will be
  represented in at least one factor of one ciphertext value. We can assign
  them in increasing order to the letters <code>A</code> through <code>Z</code>.
</p><p>
  Then, to recover the plaintext, we can use a bit of brute force to sidestep
  the need to unzip as described before. Consider the two factors that
  contribute to the first ciphertext value; arbitrarily choose one of them. Let
  us first assume that that factor corresponds to the first letter of the
  plaintext, and the other corresponds to the second. Then we can take the
  remaining factor and try to divide the second ciphertext value by that
  factor. If we cannot, we have a contradiction, and we should go back and make
  the other factor correspond to the first letter of the plaintext. Otherwise,
  the quotient is the factor corresponding to the third letter of the
  plaintext, and so on. For one of our choices, this method will work and will
  give us the correct plaintext; for the other choice, we will reach a
  contradiction, since (as described above) it is guaranteed that there is
  only one possible decryption.
</p>
<h3>Test set 2</h3>
<p>
  In test set 2, the primes can be enormous (as large as a googol), and the
  product of two such primes can be even more enormous. We should realize that
  it is hopeless to try to factor such a product. If we could do that, we
  could also break modern cryptosystems that depend on the assumption that
  factoring large numbers is intractable! The Code Jam servers do not run on
  quantum computers (yet...), so there is no way for us to try to use a
  quantum algorithm, either.
</p><p>
  To solve this seemingly impossible test set, we need to find a different
  vulnerability of this cryptosystem. The key insight is that any two
  consecutive values in the ciphertext have at least one factor in common.
  Factoring very large numbers may be intractable, but we <i>do</i> know how to
  efficiently find the greatest common divisor of two very large numbers! A
  method like <a href="https://en.wikipedia.org/wiki/Euclidean_algorithm">Euclid's algorithm</a>
  will be <a href="https://en.wikipedia.org/wiki/Euclidean_algorithm#Algorithmic_efficiency">fast enough</a>.
</p><p>
  Notice that if we have a plaintext like <code>ABABC</code>..., it is
  possible that the prime corresponding to <code>A</code> will not appear in
  any of the pairwise GCD values. So, we should compute GCDs of consecutive
  ciphertext values until we get a value that is not 1; at least one such
  value must exist, as described in the introduction to the problem. At that
  point, we can unzip the rest of the ciphertext, as described previously,
  finding all of the primes as we go. Then we can proceed as above. And we do
  not even have to know a bevy of DP flux algorithms, whatever those are!
</p>
<h3>A note on language choice</h3>
<p>
  An essential skill in Code Jam is picking the right tool (language) for the
  right job. For some problems, a fast language such as C++ may be needed to
  obtain a solution within the time limits. For this problem, it is probably
  better to choose a language like Python that can handle very large numbers
  without any extra hassle, even at the cost of some speed, or a language like
  Java that has a built-in "big integer" implementation.
</p>


  <div class="test-data-download-wrapper">
    <div class="test-data-download-header">
      <div class="test-data-download-header-text">Test Data</div>
      <div class="test-data-download-header-download-button">
        <a href="test_data.zip" target="_blank">
          <i class="material-icons grey">save_alt</i>
        </a>
      </div>
    </div>
    <div class="test-data-download-content">
      <div class="test-data-download-warning">
        <span class="material-icons" style="color: grey; vertical-align: middle;">info</span>
        <span style="vertical-align: middle;">We recommend that you practice debugging solutions without looking at the test data.</span>
      </div>
    </div>
  </div>



    </div>
  </body>
</html>
